# 触点跳动 / 触点抖动

机械开关在按下和放开时，往往不是简单的跃迁。

在理想世界中，当你按下一个开关，你将看到数字引脚像如下这样： 

（X 轴表示时间

```
电压                       +----------------------
 ^                        |
 |                        |
 |      ------------------+
          ----> 时间
```

然而在现实世界中，实际上你会看到触点跳动，看起来像是多次 1->0 和 0->1 的转换，直到这个值最终确定。

```
                  +-+ +--+ +-------------
                  | | |  | |
                  | | |  | |
+-----------------+ +-+  +-+
```
这个最终确定开关状态的时间，依据开关类型，使用时长甚至按压技巧的不同而不同。

如果设备选择不处理触点跳动，那么开关按下所产生的行为将会被重复很多次。

有很多种方式可以处理触点跳动（“去噪”）。一些会增加额外的硬件，比如 RC 滤波器，当然也有很多方式通过软件方式去除抖动，一般称作去噪算法。本页讨论在 QMK 中支持的去噪算法。

如果技术上不考虑触点跳动/触点抖动，一些开关工艺更容易被噪音影响，这意味着，当一个键未改变状态，但一些时候会在数字电路中短暂的随机 0->1 或 1->0 转换，比如：

```
                  +-+
                  | |
                  | |
+-----------------+ +--------------------
```

很多去噪方法（但不是所有）将使得设备更抗噪音。如果你使用的（设备）工艺更易受噪音影响，那你必须选择一种去噪算法来缓解噪音。

## 不同类型的去噪算法

1) 时间单位：时间戳（毫秒）与周期（扫描）
   * 去噪算法通常有一个“去噪时间”参数，它表示开关触点的最大稳定时间。这个时间可以用不同的单位来衡量：
     * 基于周期的去噪，会等待 n 个周期 (扫描)，每扫描一次矩阵，减少一个计数
     * 基于时间戳的去噪，会存储一次变动发生时的毫秒时间戳，并通过减法计算时间消耗。
   * 基于时间戳的去噪通常更好，尤其对那些抗噪设备，因为物理开关的稳定时间在单位时间内已经被指定，而且不依赖于键盘的矩阵扫描速率（matrix scan-rate）。
   * 基于周期的去噪被认为不够好，因为需要被补偿的稳定时间，取决于矩阵扫描代码的性能。如果你使用基于周期的去噪，当你明显的提升扫描代码的性能，去噪的效果可能就会下降。在一种情况下基于周期的去噪可能更可取，就是噪声存在，而且扫描算法很慢或者速度是变化的。当扫描很慢，你使用基于时间戳的算法，即使去噪算法本身抗噪，你可能最终决定你是否去噪仅取决于两个采样值（译注：前后时间戳），这将限制你算法的去噪能力。
   * 当前所有内建的去噪算法都仅支持基于时间戳的去噪。未来我们可能实现基于周期的去噪，它将可以通过一个在 ```config.h``` 中的宏来选择。
2) 对称与非对称
   * 对称的 - 在键按下和键弹起事件中，使用相同的去噪算法。
     * 推荐命名方式： ```sym_*```
   * 非对称的 - 在键按下和键弹起事件中，使用不同的去噪算法。例如，立即键按下，延迟键弹起。
     * 推荐命名方式： ```asym_*``` 后面接使用算法的详情，按顺序，键按下和键弹起。
3) 立即与延迟
   * 立即 - 立即报告所有键变化。所有进一步的去噪毫秒数将被忽略。
     * 立即算法不是抗噪的。
     * 推荐命名方式：
        * ```sym_eager_*```
        * ```asym_eager_*_*```：键按下使用立即算法
        * ```asym_*_eager_*```：键弹起使用立即算法
   * 延迟 - 在报告变化前，等待去噪毫秒数不在发生变化。
     * 延迟算法是抗噪的。
     * 推荐命名方式：
        * ```sym_defer_*```
        * ```asym_defer_*_*```：键按下使用延迟算法
        * ```asym_*_defer_*```：键弹起使用延迟算法
4) 全局、按键、按行
   * 全局 - 所有键使用一个计时器。所有的键变化状态都会影响全局计时器。
     * 推荐命名方式： ```*_g```
   * 按键 - 一个键对应一个计时器
     * 推荐命名方式： ```*_pk```
   * 按行 - 一行对应一个计时器
     * 推荐命名方式： ```*_pr```
   * 按键和按行算法消费更多的资源（在条数上，和内存使用上），但是快速的打字员可能更倾向于使用全局方式。

## QMK 支持的去噪算法

QMK 通过它的去噪 API，支持多种去噪算法。

### 去噪选择

| 去噪类型 | 描述                                 | 备注                                                       |
| -------- | ------------------------------------ | ---------------------------------------------------------- |
| 未定义   | 使用默认算法，目前是 sym_defer_g     | 无                                                         |
| 自定义   | 使用你自己的去噪算法                 | ```SRC += debounce.c``` 添加你的 debounce.c 并实现必要函数 |
| 其他     | 使用 quantum/debounce/* 中的其他算法 | 无                                                         |

**关于分割键盘**:
去噪代码与分割键盘兼容。

### 选择一个包含的去噪方法
键盘可以选择一个已经实现的去噪算法，通过在 ```rules.mk``` 添加如下配置：

```
DEBOUNCE_TYPE = <算法名称>
```
算法名称为如下之一:
* ```sym_defer_g``` - 每个键盘的去噪算法。在任意状态变化时，设置一个全局的计时器。当发现 ```DEBOUNCE``` 毫秒数不在变化，所有输入的变化将被推送。
  
  * 这个是当前默认的算法。它是最高性能的算法，同时使用最低的内存，而且还是抗噪的。
  
* ```sym_eager_pr``` - 按行去噪。在任意状态变化时，立即响应，然后锁住此行 ```DEBOUNCE``` 毫秒数，是其后续不在此行输入。

  适用于这些键盘，刷新 ```NUM_KEYS``` 8位计数器，运算成本高/扫描率低，而且手指通常一个时刻仅点击同一行。这比较适用于 ErgoDox 形式（的键盘）。矩阵选转了 90°，因此它的“行”其实是列，通常使用时，一个时刻每个手指仅点击一个“行”。

* ```sym_eager_pk``` - 按键去噪。在任意状态变化时，立即响应，然后锁住此键 ```DEBOUNCE``` 毫秒数，是其后续不在此行输入。

* ```sym_defer_pr``` - 按行去噪。在任意状态变化时，设置一个按行的计时器。当发现此行 ```DEBOUNCE``` 毫秒数不在变化，整行被推送。可以比 `sym_defer_g` 更好的进行响应，同时相比按键去噪，受噪声影响更小。

* ```sym_defer_pk``` - 按键去噪。在任意状态变化时，设置一个按键的计时器。当发现此键 ```DEBOUNCE``` 毫秒数不在变化，此键状态被推送。

* ```asym_eager_defer_pk``` - 当键按下状态发生，立即响应，然后锁住此键 ```DEBOUNCE``` 毫秒数，是其后续不在此键输入。当键弹起状态发生，设置一个按键的计时器，当发现此键 ```DEBOUNCE``` 毫秒数不在变化，此键状态被推送。

### 未来将实现的两种算法：
* ```sym_defer_pr```
* ```sym_eager_g```

### 使用自己的去噪代码
你可以选择实现自己的去噪算法。需要做这些：

*  ```rules.mk``` 中设置 ```DEBOUNCE_TYPE = custom```
*  ```rules.mk``` 中添加 ```SRC += debounce.c```
* 添加自己的 ```debounce.c```。参考当前实现 ```quantum/debounce``` 作为例子
* 去噪发生在每次 raw matrix 扫描。
* 使用 num_rows 而不是 MATRIX_ROW，这样分割键盘也可以被正确支持。
* 如果算法适用于其他键盘，请考虑添加到 ```quantum/debounce```
