# 分割キーボード

QMK ファームウェアリポジトリの多くのキーボードは、"分割"キーボードです。それらは2つのコントローラを使います — 1つは USB に接続し、もう1つは TRRS または同様のケーブルを介してシリアルまたは I<sup>2</sup>C 接続で接続します。

分割キーボードには多くの利点がありますが、有効にするには追加の作業が必要です。

QMK ファームウェアには、任意のキーボードで使用可能な一般的な実装と、多くのキーボード固有の実装があります。

このため、主に Let's Split とその他のキーボードで使われる一般的な実装について説明します。

!> ARM は分割キーボードについてはまだサポートされません。進捗は進んでいますが、まだ十分ではありません。


## ハードウェア設定

2つの Pro Micro 互換のコントローラを使っており、2つの半分のキーボードに接続するために TRRS ジャックを使っていることを前提とします。

### ハードウェア要件

各半分のキーボードマトリックスのためのダイオードとスイッチとは別に、2x TRRS ソケットと 1x TRRS ケーブルが必要です。

あるいは、少なくとも3本のワイヤがあるケーブルとソケットを使うことができます。

半分のキーボードの間で通信するために I<sup>2</sup>C を使いたい場合は、少なくとも4本のワイヤと 2x 4.7kΩ プルアップ抵抗を備えたケーブルが必要です。

#### 考慮事項

最も一般的に使われる接続は、TRRS ケーブルとジャックです。これらは4本のワイヤを提供し、分割キーボードに非常に有用で、簡単に見つけることができます。

ただし、ワイヤのうちの1つが VCC を伝送するため、キーボードがホットプラグ可能では無いことを意味します。TRRS ケーブルを抜き差しする前に、常に USB からキーボードを切断する必要があります。そうしなければ、コントローラを短絡させるか、さらに悪い場合があります。

別のオプションは電話ケーブルを使うことです (例えば、旧式の RJ-11/RJ-14 ケーブル)。実際に4本のワイヤ/レーンをサポートするものを使うようにしてください。

ただし、コントローラ間の通信には、USB ケーブル、SATA ケーブル、ちょうど4本のワイヤのいずれも使用されることが知られています。

!> コントローラ間の通信に USB ケーブルを使っても問題ありませんが、コネクタは通常の USB 接続と間違えられるかもしれず、配線方法によってはキーボードが短絡する可能性があります。このため、分割キーボードの接続のためにはお勧めできません。

### シリアル配線

TRS/TRRS ケーブルの3本のワイヤは、2つの Pro Micro 間で GND、VCC、D0 (別名 PDO あるいは pin 3) の全てを接続する必要があります。

?> ここで使われるピンは実際には以下の `SOFT_SERIAL_PIN` によって設定されることに注意してください。

![シリアル配線](https://i.imgur.com/C3D1GAQ.png)

### I<sup>2</sup>C 配線

TRRS ケーブルの4本のワイヤは、2つの Pro Micro 間で GND、VCC、SCL、SDA (それぞれ 別名 PD0/pin 3 および PD1/pin 2) 全てを接続する必要があります。

プルアップ抵抗はどちらの片側のキーボードにも配置することができます。4つの抵抗を使い、両方の半分にプルアップを使うこともできますが、これは単純な使用例では不要です。

![I2C 配線](https://i.imgur.com/Hbzhc6E.png)

## ファームウェア設定

分割キーボード機能を有効にするには、以下を `rules.mk` に追加してください:

```make
SPLIT_KEYBOARD = yes
```

カスタムトランスポート (通信メソッド)を使っている場合は、以下を追加する必要もあります:

```make
SPLIT_TRANSPORT = custom
```

### 左右の設定

デフォルトでは、ファームウェアはどちら側がどちらであるかを認識しません; 決定するには幾つかの助けが必要です。これを行うには幾つかの方法があり、以下に優先順に列挙します。

#### ピンによる左右の設定

左右を決定するためにコントローラ上のピンを読むようにファームウェアを設定することができます。これを行うには、以下を `config.h` ファイルに追加します:

```c
#define SPLIT_HAND_PIN B7
```

これは指定されたピンを読み込みます。high の場合、コントローラはそれを左側だと仮定し、low の場合、それは右側であると仮定します。

#### EEPROM による左右の設定

このメソッドは永続ストレージ内のフラグを設定することで、キーボードの左右を設定します (`EEPROM`)。これはコントローラが最初に起動する時にチェックされ、キーボードのどちら側であるかとキーボードのレイアウトの向きを決定します。


このメソッドを有効にするには、以下を `config.h` ファイルに追加します:

```c
#define EE_HANDS
```

ただし、各コントローラの正しい左右の設定のために EEPROM ファイルを書き込む必要があります。これを手動で行うことができます。あるいは、avrdude および dfu ではファームウェアを書き込む時に対象を指定します。

* `:avrdude-split-left`
* `:avrdude-split-right`
* `:dfu-split-left`
* `:dfu-split-right`
* `:dfu-util-split-left`
* `:dfu-util-split-right`

この設定は、`EEP_RST` キーを使うか、`eeconfig_init()` 関数を使うことで EEPROM を再初期化する時に変更されません。ただし、ファームウェアの組み込みオプションの外側で EEPROM をリセット([QMK Toolbox]() の "Reset EEPROM" ボタンの動作のように、`EEPROM` を上書きするファイルを書きこむなど)する場合、`EEPROM` ファイルを使って再書き込みする必要があります。

QMK ファームウェアのリポジトリ内の `EEPROM` ファイルは、[ここ](https://github.com/qmk/qmk_firmware/tree/master/quantum/split_common)で見つけることができます。

#### `#define` による左右の設定

コンパイル時に左右を設定することができます。これは以下を `config.h` ファイルに追加することで行うことができます:

```c
#define MASTER_RIGHT
```

あるいは

```c
#define MASTER_LEFT
```

どちらも定義されていない場合、左右のデフォルトは `MASTER_LEFT` になります。


### 通信オプション

全ての分割キーボードが同一であるとは限らないため、`config.h` ファイル内で設定することができる多くの追加のオプションがあります。

```c
#define USE_I2C
```

これは分割キーボードの I<sup>2</sup>C サポートを有効にします。これは厳密には通信用ではありませんが、OLED あるいは I<sup>2</sup>C ベースのデバイスに使うことができます。

```c
#define SOFT_SERIAL_PIN D0
```

これはシリアル通信用に使われるピンを設定します。シリアルを使っていない場合は、これを定義する必要はありません。

ただし、ボード上でシリアルおよび I<sup>2</sup>C を使っている場合は、これを設定し、D0 および D1 以外の値に設定する必要があります (これらは I<sup>2</sup>C 通信のために使われます)。

```c
#define SELECT_SOFT_SERIAL_SPEED {#}`
```

シリアル通信に問題がある場合は、この値がシリアル用の通信速度を制御するため、この値を変更することができます。デフォルトは1で、可能な値は以下の通りです:

* **`0`**: 約189kbps (実験のみ)
* **`1`**: 約137kbps (デフォルト)
* **`2`**: 約75kbps
* **`3`**: 約39kbps
* **`4`**: 約26kbps
* **`5`**: 約20kbps

### ハードウェア設定オプション

ハードウェアのセットアップ方法に基づいて、設定する必要のある設定が幾つかあります。

```c
#define MATRIX_ROW_PINS_RIGHT { <row pins> }
#define MATRIX_COL_PINS_RIGHT { <col pins> }
```

これにより、右側のマトリックスに異なるピンのセットを指定することができます。これは、異なる設定を必要とする異なる形状の半分のキーボード (Keebio の Quefrency など)がある場合に便利です。

```c
#define DIRECT_PINS_RIGHT { { F1, F0, B0, C7 }, { F4, F5, F6, F7 } }
```

これにより右側のための異なる直接ピンのセットを指定することができます。

```c
#define ENCODERS_PAD_A_RIGHT { encoder1a, encoder2a }
#define ENCODERS_PAD_B_RIGHT { encoder1b, encoder2b }
```

これにより右側のための異なるエンコードピンのセットを指定することができます。

```c
#define RGBLIGHT_SPLIT
```

このオプションは、分割キーボードのコントローラ間で RGB ライトモードの同期を有効にします。これはコントローラに直接配線されている RGB LED を持つキーボードです (つまり、それらは TRRS ケーブルで "追加データ"オプションを使っていません)。

```c
#define RGBLED_SPLIT { 6, 6 }
```

これは各コントローラに直接接続されてる LED の数を設定します。最初の数は左側、2番目の数は右側です。

?> この設定は `RGBLIGHT_SPLIT` が有効になっていることを意味し、有効になっていない場合は強制的に有効にします。


```c
#define SPLIT_USB_DETECT
```
このオプションは、マスタ/スレーブの決定時にアクティブな USB 接続を検出するためにスタートアップの挙動を変更します。このオプションがタイムアウトになった場合、その片側はスレーブと見なされます。これは ARM のデフォルトの挙動で、AVR Teensy ボードに必要です (ハードウェアの制限のため)。

?> この設定はバッテリパックを使ったデモの機能を停止します。

```c
#define SPLIT_USB_TIMEOUT 2000
```
これは、`SPLIT_USB_DETECT` を使う時のマスタ/スレーブを検出する場合の最大タイムアウトを設定します。

```c
#define SPLIT_USB_TIMEOUT_POLL 10
```
これは `SPLIT_USB_DETECT` を使う時のマスタ/スレーブを検出する場合のポーリング頻度を設定します

## 追加のリソース(英語)

Nicinabox には Let's Split キーボードのための[非常に優れた詳細なガイド](https://github.com/nicinabox/lets-split-guide)があり、トラブルシューティング情報を含む知っておくべきほとんど全てをカバーします。

ただし、RGB ライトセクションは、RGB Split コードが QMK ファームウェアに追加されるずっと前に書かれたため、古くなっています。そうしないで、各ストリップを直接コントローラに配線します。

<!-- I may port this information later, but for now ... it's very nice, and covers everything -->
