# 分割キーボード

QMKファームウェア レポジトリの多くのキーボードは、"分割"キーボードです。それらは2つのコントローラを使います — 1つはUSBに接続し、もう1つはTRRSまたは同様のケーブルを介してシリアルまたは I<sup>2</sup>C 接続で接続します。

分割キーボードには多くの利点がありますが、有効にするには追加の作業が必要です。

QMKファームウェアには、任意のボードで使用可能な一般的な実装と、多くのボード固有の実装があります。

このため、主に Let's Split とその他のキーボードで使われる一般的な実装について説明します。

!> ARMは分割キーボードについてはまだサポートされません。進捗は進んでいますが、まだ十分ではありません。


## ハードウェア設定

2つのPro Micro-互換のコントローラを使っており、2つの半分に接続するためにTRRSジャックを使っていることを前提とします。

### ハードウェア要件

各半分のキーボードマトリックスのためのダイオードとスイッチとは別に、2x TRRS ソケットと 1x TRRS ケーブルが必要です。

あるいは、少なくとも3本のワイヤがあるケーブルとソケットを使うことができます。

半分の間で通信するために I<sup>2</sup>C を使いたい場合は、少なくとも4本のワイヤと 2x 4.7kΩ プルアップ抵抗を備えたケーブルが必要です。

#### 考慮事項

最も一般的に使われる接続は、TRRSケーブルとジャックです。これらは4本のワイヤを提供し、分割キーボードに非常に有用で、簡単に見つけることができます。

ただし、ワイヤのうちの1つがVCCを伝送するため、ボードがホットプラグ可能では無いことを意味します。TRRSケーブルを抜き差しする前に、常にUSBからボードを切断する必要があります。そうしなければ、コントローラを短絡させるか、さらに悪い場合があります。

別のオプションは電話ケーブルを使うことです (例えば、旧式の RJ-11/RJ-14 ケーブル)。実際に4本のワイヤ/レーンをサポートするものを使うようにしてください。

ただし、コントローラ間の通信には、USBケーブル、SATAケーブル、およびちょうど4本のワイヤが使用されることが知られています。

!> コントローラ間の通信にUSBケーブルを使っても問題ありませんが、コネクタは通常のUSB接続と間違えられるかもしれず、配線方法によってはキーボードが短絡する可能性があります。このため、分割キーボードの接続のためにはお勧めできません。

### シリアル配線

TRS/TRRS ケーブルの3本のワイヤは、2つのPro Micros間で GND, VCC および D0 (別名 PDO あるいは pin 3) を接続する必要があります。

?> ここで使われるピンは実際には以下の`SOFT_SERIAL_PIN`によって設定されることに注意してください。

![シリアル配線](https://i.imgur.com/C3D1GAQ.png)

### I<sup>2</sup>C 配線

TRRSケーブルの4本のワイヤは、2つのPro Micros間で GND, VCC, SCL および SDA (それぞれ 別名 PD0/pin 3 および PD1/pin 2) を接続する必要があります。

プルアップ抵抗はどちらの半分にも配置することができます。4つの抵抗を使い、両方の半分にプルアップを使うこともできますが、これは単純な使用例では不要です。

![I2C配線](https://i.imgur.com/Hbzhc6E.png)

## ファームウェア設定

分割キーボード機能を有効にするには、以下を`rules.mk`に追加してください:

```make
SPLIT_KEYBOARD = yes
```

カスタム トランスポート (通信メソッド)を使っている場合は、以下を追加する必要もあります:

```make
SPLIT_TRANSPORT = custom
```

### 左右の設定

デフォルトでは、ファームウェアはどちら側がどちらであるかを認識しません; 決定するには幾つかの助けが必要です。これを行うには幾つかの方法があり、優先順にリストします。

#### ピンによる左右の設定

左右を決定するためにコントローラ上のピンを読むようにファームウェアを設定することができます。これを行うには、以下を `config.h` ファイルに追加しまう:

```c
#define SPLIT_HAND_PIN B7
```

これは指定されたピンを読み込みます。高の場合、コントローラはそれを左手だと仮定し、低の場合、それは右側であると仮定します。

#### EEPROMによる左右の設定

このメソッドは永続ストレージ内のフラグを設定することで、キーボードの左右を設定します (`EEPROM`)。これはコントローラが最初に起動する時にチェックされ、キーボードの半分とキーボードのレイアウトの向きを決定します。


このメソッドを有効にするには、以下を`config.h` ファイルに追加します:

```c
#define EE_HANDS
```

ｔだし、各コントローラの正しい左右の設定のためにEEPROMファイルをフラッシュする必要があります。You can do this manually, or there are targets for avrdude and dfu to do this, while flashing the firmware:

* `:avrdude-split-left`
* `:avrdude-split-right`
* `:dfu-split-left`
* `:dfu-split-right`
* `:dfu-util-split-left`
* `:dfu-util-split-right`

この設定は、`EEP_RST`キーを使うか、`eeconfig_init()`関数を使うことでEEPROMを再初期化する時に変更されません。However, if you reset the EEPROM outside of the firmware's built in options (such as flashing a file that overwrites the `EEPROM`, like how the [QMK Toolbox]()'s "Reset EEPROM" button works), you'll need to re-flash the controller with the `EEPROM` files.

QMKファームウェアのレポジトリ内の`EEPROM` ファイルは、[ここ](https://github.com/qmk/qmk_firmware/tree/master/quantum/split_common)で見つけることができます。

#### `#define`による利き手

コンパイル時に利き手を設定することができます。これは以下を`config.h`ファイルに追加することで行うことができます:

```c
#define MASTER_RIGHT
```

あるいは

```c
#define MASTER_LEFT
```

どちらも定義されていない場合、利き手のデフォルトは`MASTER_LEFT`になります。


### 通信オプション

全ての分割キーボードが同一であるとは限らないため、`config.h`ファイル内で設定することができる多くの追加のオプションがあります。

```c
#define USE_I2C
```

これは分割キーボードの I<sup>2</sup>C サポートを有効にします。これは厳密には通信用ではありませんが、OLEDあるいは I<sup>2</sup>Cベースのデバイスに使うことができます。

```c
#define SOFT_SERIAL_PIN D0
```

これはシリアル通信用に使われるピンを設定します。シリアルを使っていない場合は、これを定義する必要はありません。

ただし、ボード上でシリアルおよびI<sup>2</sup>Cを使っている場合は、これを設定し、D0およびD1以外の値に設定する必要があります (これらは I<sup>2</sup>C通信のために使われます)。

```c
#define SELECT_SOFT_SERIAL_SPEED {#}`
```

シリアル通信に問題がある場合は、この値がシリアル用の通信速度を制御するため、この値を変更することができます。デフォルトは1で、可能な値は以下の通りです:

* **`0`**: 約189kbps (実験のみ)
* **`1`**: 約137kbps (デフォルト)
* **`2`**: 約75kbps
* **`3`**: 約39kbps
* **`4`**: 約26kbps
* **`5`**: 約20kbps

### ハードウェア設定オプション

ハードウェアのセットアップ方法に基づいて、設定する必要のある設定が幾つかあります。

```c
#define MATRIX_ROW_PINS_RIGHT { <row pins> }
#define MATRIX_COL_PINS_RIGHT { <col pins> }
```

これにより、右側のマトリックスに異なるピンのセットを指定することができます。これは、異なる設定を必要とする異なる形状の半分のボード (KeebioのQuefrencyなど)がある場合に便利です。

```c
#define DIRECT_PINS_RIGHT { { F1, F0, B0, C7 }, { F4, F5, F6, F7 } }
```

これにより右側のための異なる直接ピンのセットを指定することができます。

```c
#define ENCODERS_PAD_A_RIGHT { encoder1a, encoder2a }
#define ENCODERS_PAD_B_RIGHT { encoder1b, encoder2b }
```

これにより右側のための異なるエンコードピンのセットを指定することができます。

```c
#define RGBLIGHT_SPLIT
```

このオプションは、分割キーボードのコントローラ間でRGBライトモードの同期を有効にします。これはコントローラに直接配線されているRGB LEDを持つキーボードです (つまり、それらはTRRSケーブルで "追加データ" オプションを使っていません)。

```c
#define RGBLED_SPLIT { 6, 6 }
```

これは各コントローラに直接接続されてるLEDの数を設定します。最初の数は左側、2番目の数は右側です。

?> この設定は `RGBLIGHT_SPLIT` が有効になっていることを意味し、有効になっていない場合は強制的に有効にします。


```c
#define SPLIT_USB_DETECT
```
このオプションは、マスタ/スレーブの移譲時にアクティブなUSB接続を検出するためにスタートアップの挙動を変更します。このオプションがタイムアウトになった場合、その半分はスレーブと見なされます。これはARMのデフォルトの挙動で、AVR Teensy ボードに必要です (ハードウェアの制限のため)。

?> この設定はバッテリパックを使ったデモの機能を停止します。

```c
#define SPLIT_USB_TIMEOUT 2500
```
これは、`SPLIT_USB_DETECT`を使う時のマスタ/スレーブを検出する場合の最大タイムアウトを設定します。

## 追加のリソース

NicinaboxにはLet's Splitキーボードのための[非常に優れた詳細なガイド](https://github.com/nicinabox/lets-split-guide)があり、トラブルシューティング情報名を含む知っておくべきほとんど全てをカバーします。

ただし、RGBライト セクションは、RGB SplitコードがQMKファームウェアに追加されるずっと前に書かれたため、古くなっています。代わりに、各ストリップを直接コントローラに配線します。

<!-- I may port this information later, but for now ... it's very nice, and covers everything -->
