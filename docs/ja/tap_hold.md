# タップホールド設定オプション

<!---
  original document: 0.9.51:docs/tap_hold.md
  git diff 0.9.51 HEAD -- docs/tap_hold.md | cat
-->

タップホールドオプションは素晴らしいですが、問題が無いわけではありません。合理的なデフォルトでそれらを設定しようとしていますが、一部の人にとってまだ問題を引き起こすかもしれません。

これらのオプションによりタップホールドキーの挙動を変更することができます。

## タッピング条件

以下の機能の全ての核心は、タッピング条件の設定です。これにより、タップとホールドが決まります。自然に感じられる正確なタイミングは、キーボードごと、スイッチごと、キーごとに異なるかもしれません。

`config.h` に以下の設定を追加することで、このグローバル時間を設定することができます:

```c
#define TAPPING_TERM 200
```

この設定はミリ秒で定義され、デフォルトは 200ms です。これは大多数の人にとっての適切な平均値です。

この機能をより細かく制御するために、以下を `config.h` に追加することができます:
```c
#define TAPPING_TERM_PER_KEY
```

そして、以下の関数をキーマップに追加します:

```c
uint16_t get_tapping_term(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case SFT_T(KC_SPC):
            return TAPPING_TERM + 1250;
        case LT(1, KC_GRV):
            return 130;
        default:
            return TAPPING_TERM;
    }
}
```


## 許容ホールド

[PR#1359](https://github.com/qmk/qmk_firmware/pull/1359/) の時点で、新しい `config.h` オプションがあります:

```c
#define PERMISSIVE_HOLD
```

これは高速なタイピストや高い `TAPPING_TERM` 設定に対して、タップとホールドキー(モッドタップのような)動作を向上させます。

モッドタップキーを押し、他のキーをタップ(押して放す)して、モッドタップキーを放すと、全てのタッピング時間内で両方のキーの「タッピング」機能が出力されます。

例えば:

- `SFT_T(KC_A)` ダウン
- `KC_X` ダウン
- `KC_X` アップ
- `SFT_T(KC_A)` アップ

通常、これら全てを `TAPPING_TERM` (デフォルト: 200ms) 内で行うと、ファームウェアとホストシステムによって `ax` として登録されます。許容ホールドを有効にすると、別のキーがタップされた場合にモッドタップキーを Mod と見なすことで処理され、 `X` として登録されます (`SHIFT`+`x`)。

?> `モッドタップ割り込みの無視`を有効にしている場合、これにより両方の動きが変更されます。最初のキーが最初に放された場合、あるいは両方のキーが `TAPPING_TERM` より長くホールドされた場合に、通常のキーにモディファイアが追加されます。

この機能をより細かく制御するために、以下を `config.h` に追加することができます:

```c
#define PERMISSIVE_HOLD_PER_KEY
```

そして、以下の関数をキーマップに追加します:

```c
bool get_permissive_hold(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case LT(1, KC_BSPC):
            return true;
        default:
            return false;
    }
}
```

## Mod タイプ割り込みの無視

この設定を有効にするには、これを `config.h` に追加してください:

```c
#define IGNORE_MOD_TAP_INTERRUPT
```

許容ホールドと同様に、これは高速なタイピストのためのファームウェアの処理方法を変更します。モッドタップキーを押し、他のキーを押し、モッドタップキーを放し、通常のキーを放すと、通常は両方のキーについての "タッピング" の機能が出力されます。これはローリングコンボキーには望ましくないかもしれません。

`モッドタップ割り込みの無視`の設定には、ホールド機能 (mod) を引き起こすために `TAPPING_TERM` の両方のキーを必要とします。

例えば:

- `SFT_T(KC_A)` ダウン
- `KC_X` ダウン
- `SFT_T(KC_A)` アップ
- `KC_X` アップ

通常、これは `X` を送信します (`SHIFT`+`x`)。`モッドタップ割り込みの無視`を有効にすると、ホールドアクションを登録するために、`TAPPING_TERM` に両方のキーをホールドする必要があります。この場合、素早いタップは `ax` を送信しますが、両方をホールドすると、`X`  (`SHIFT`+`x`) を出力します。


?> __注意__: これはモディファイアにのみ関係し、レイヤー切り替えキーには関係しません。

?> `許容ホールド`を有効にすると、これは両方がどのように動作するかを変更します。通常のキーには、最初のキーが最初に放された場合、あるいは両方のキーが `TAPPING_TERM` より長くホールドされた場合に、モディファイアが追加されます。

この機能をより細かく制御するために、以下を `config.h` に追加することができます:

```c
#define IGNORE_MOD_TAP_INTERRUPT_PER_KEY
```

そして、以下の関数をキーマップに追加します:

```c
bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case SFT_T(KC_SPC):
            return true;
        default:
            return false;
    }
}
```

## タッピングフォースホールド

`タッピングフォースホールド` を有効にするには、以下を `config.h` に追加します:

```c
#define TAPPING_FORCE_HOLD
```

タップの後でユーザがキーをホールドすると、これは修飾キーをホールドするかわりにタップされたキーを繰り返します。これにより、タップされたキーのために自動繰り返しを使うことができます。

例:

- SFT_T(KC_A) ダウン
- SFT_T(KC_A) アップ
- SFT_T(KC_A) ダウン
- タッピング時間より長く待ちます...
- SFT_T(KC_A) アップ

デフォルトの設定では、最初のリリースで `a` が送信され、2回目の押下で `a` が送信され、コンピュータに自動リピート機能をさせることができます。

`TAPPING_FORCE_HOLD` を使うと、2回目の押下はシフトとして解釈され、それをタップして使った後ですぐにモディファイアとして使うことができます。

!> `TAPPING_FORCE_HOLD` はタッピングトグル(`TT` レイヤーのキーコード、ワンショットタッピングトグルなど)を使うものをすべて破壊します。

この機能をより細かく制御するために、以下を `config.h` に追加することができます:

```c
#define TAPPING_FORCE_HOLD_PER_KEY
```

そして、以下の関数をキーマップに追加します:

```c
bool get_tapping_force_hold(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case LT(1, KC_BSPC):
            return true;
        default:
            return false;
    }
}
```

## レトロタッピング

`レトロタッピング`を有効にするには、以下のものを `config.h` に追加してください:

```c
#define RETRO_TAPPING
```

他のキーを押さずにデュアルファンクションキーを押して放しても何も起こりません。レトロタップを有効にすると、他のキーを押さずにキーを放すと、元のキーコードがタッピング時間外であっても送信されます。

例えば、他のキーを押すことなく `LT(2, KC_SPACE)` を押したり放したりしても何も起こりません。これを有効にすると、代わりに `KC_SPACE` を送信します。

## キーの関数ごとにキーのレコードを含めるのはなぜですか？

「キーごと」の関数全てにキーレコードを含んでいることに気付いたかもしれません。そしてなぜそうしたのか不思議に思っているかもしれません。

まぁ、それは単純に本当にカスタマイズのためです。ただし、具体的には、それはキーボードの配線方法によって異なります。例えば、各行が実際にキーボードのマトリックスの行を使っている場合、キーコード全体をチェックする代わりに、`if (record->event.row == 3)` を使うほうが簡単かもしれません。これは、ホームキー行でタップホールドタイプのキーを使っている人にとって特に便利です。そのため、通常のタイピングを妨げないように微調整することができるのではないでしょうか。

## `*_kb` or `*_user` 関数が無いのはなぜですか？

ここにある他の多くの関数とは異なり、quantum あるいはキーボードレベルの関数を持つ必要はありません (または理由さえありません)。ここではユーザレベルの関数だけが有用なため、そのようにマークする必要はありません。
