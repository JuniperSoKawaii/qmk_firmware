# 高度なキーコード

<!---
  original document: 0d3f0889c:docs/feature_advanced_keycodes.md
  git diff 0d3f0889c HEAD -- docs/feature_advanced_keycodes.md | cat
-->

キーマップに通常より高度なキーコード、例えば、押し続けた時はレイヤーを切り替えたりモディファイアを送信したりしますが、タップした時は通常のキーコードを送信するようなキーコードを含めることができます。このページでは利用可能な機能を説明します。

## カスタム名の割り当て

`#define` を使ってカスタム名を定義することがあります。例えば:

```c
#define FN_CAPS LT(_FL, KC_CAPSLOCK)
#define ALT_TAB LALT(KC_TAB)
```

これにより、キーマップ内で `FN_CAPS` および `ALT_TAB` を使うことができ、読みやすくなります。

## 注意事項

現在のところ、`LT()` と `MT()` は[基本的なキーコードセット](ja/keycodes_basic.md)に制限されています。つまり、`LCTL()`、`KC_TILD` あるいは `0xFF` より大きなキーコードを使うことができません。レイヤータップあるいはモッドタップのキーコードの一部として指定されたモディファイアは無視されます。タップしたキーコードにモディファイアを適用する必要がある場合は、[タップダンス](ja/feature_tap_dance.md#example-5-using-tap-dance-for-advanced-mod-tap-and-layer-tap-keys)を使うことができます。

さらに、モッドタップあるいはレイヤータップで少なくとも1つの右側用のモディファイアが指定された場合、指定された全てのモディファイアが右側用になるため、2つをうまく組み合わせて一致させることはできません。

# レイヤーの切り替えとトグル

これらの機能により、様々な方法でレイヤーをアクティブ化することができます。レイヤーは一般的に独立したレイアウトでは無いことに注意してください -- 複数のレイヤーを一度にアクティブ化することができ、レイヤーが `KC_TRNS` を使ってキーの押下を下のレイヤーに渡すことが一般的です。レイヤーの詳細については、[キーマップの概要](ja/keymap.md#keymap-and-layers)を見てください。MO()、LM()、TT() あるいは LT() を使って一時的なレイヤーの切り替えを使う場合、上のレイヤーのキーを透過にするようにしてください。さもないと意図したように動作しないかもしれません。

* `DF(layer)` - デフォルトレイヤーを切り替えます。デフォルトレイヤーは、他のレイヤーがその上に積み重なっている、常にアクティブな基本レイヤーです。デフォルトレイヤーの詳細については以下を見てください。これは QWERTY から Dvorak レイアウトに切り替えるために使うことができます。(これは一時的な切り替えであり、キーボードの電源が切れるまでしか持続しないことに注意してください。デフォルトレイヤーを永続的に変更するには、[process_record_user](ja/custom_quantum_functions.md#programming-the-behavior-of-any-keycode) 内で `set_single_persistent_default_layer` 関数を呼び出すなど、より深いカスタマイズが必要です。)
* `MO(layer)` - 一時的に*レイヤー*をアクティブにします。キーを放すとすぐに、レイヤーは非アクティブになります。
* `LM(layer, mod)` - (`MO` のように)一時的に*レイヤー*をアクティブにしますが、モディファイア *mod* がアクティブな状態です。layer 0-15 と、左モディファイアのみをサポートします: `MOD_LCTL`、`MOD_LSFT`、`MOD_LALT`、`MOD_LGUI` (`KC_` の代わりに `MOD_` 定数を使うことに注意してください)。これらのモディファイアは、例えば `LM(_RAISE, MOD_LCTL | MOD_LALT)` のように、ビット単位の OR を使って組み合わせることができます。
* `LT(layer, kc)` - ホールドされた時に*レイヤー*を一時的にアクティブにし、タップされた時に *kc* を送信します。layer 0-15 のみをサポートします。
* `OSL(layer)` - 次のキーが押されるまで、一時的に*レイヤー*をアクティブにします。詳細と追加機能については、[ワンショットキー](#one-shot-keys)を見てください。
* `TG(layer)` - *レイヤー*を切り替えます。非アクティブな場合はアクティブにし、逆も同様です。
* `TO(layer)` - *レイヤー*をアクティブにし、他の全てのレイヤー(デフォルトレイヤーを除く)を非アクティブにします。この関数は特別です。1つのレイヤーをアクティブなレイヤースタックに追加/削除する代わりに、現在のアクティブなレイヤーを完全に置き換え、唯一上位のレイヤーを下位のレイヤーで置き換えることができるからです。これはキーダウンで(キーが押されるとすぐに)アクティブになります。
* `TT(layer)` - レイヤーのタップ切り替え。キーを押したままにすると*レイヤー*がアクティブにされ、放すと非アクティブになります (`MO` 風)。繰り返しタップすると、レイヤーはオンあるいはオフを切り替えます (`TG` 風)。デフォルトでは5回のタップが必要ですが、`TAPPING_TOGGLE` を定義することで変更することができます -- 例えば、2回のタップだけで切り替えるには、`#define TAPPING_TOGGLE 2` を定義します。

# レイヤーの使用

レイヤーを切り替える時は注意してください。(キーボードを取り外さずに)そのレイヤーを非アクティブにすることができずレイヤーから移動できなくなる可能性があります。最も一般的な問題を避けるためのガイドラインを作成しました。

## 初心者

QMK を使い始めたばかりの場合は、全てを単純にしたいでしょう。レイヤーをセットアップする時は、これらのガイドラインに従ってください:

* デフォルトの "base" レイヤーとして、layer 0 をセットアップします。これは通常の入力レイヤーであり、任意のレイアウト (qwerty、dvorak、colemak など)にすることができます。通常はキーボードのキーのほとんどまたは全てが定義されているため、これを最下位のレイヤーとして設定することが重要です。そうすることで、もしそれが他のレイヤーの上 (つまりレイヤー番号が大きい)にある場合の影響を防ぎます。
* layer 0 をルートとして、レイヤーを "ツリー" レイアウトに配置します。他の複数のレイヤーから同じレイヤーを入力しようとしないでください。
* 各レイヤーのキーマップでは、より高い番号のレイヤーのみを参照します。レイヤーは最大の番号(最上位)のアクティブレイヤーから処理されるため、下位レイヤーの状態を変更するのは難しくエラーが発生しやすくなります。

## 中級ユーザ

複数の基本レイヤーが必要な場合があります。例えば、QWERTY と Dvorak を切り替える場合、国ごとに異なるレイアウトを切り替える場合、あるいは異なるビデオゲームごとにレイアウトを切り替える場合などです。基本レイヤーは常に最小の番号のレイヤーである必要があります。複数の基本レイヤーがある場合、常にそれらを相互排他的に扱う必要があります。1つの基本レイヤーがオンの場合、他をオフにします。

## 上級ユーザ

レイヤーがどのように動作し、何ができるかを理解したら、より創造的になります。初心者のセクションで列挙されている規則は、幾つかの巧妙な詳細を回避するのに役立ちますが、特に超コンパクトなキーボードのユーザにとって制約になる場合があります。レイヤーの仕組みを理解することで、レイヤーをより高度な方法で使うことができます。

レイヤーは番号順にお互いの上に重なり合っています。キーの押下の動作を決定する時に、QMK は上から順にレイヤーを走査し、`KC_TRNS` に設定されていない最初のアクティブなレイヤーに到達すると停止します。結果として、現在のレイヤーよりも数値的に低いレイヤーをアクティブにし、現在のレイヤー(あるいはアクティブでターゲットレイヤーよりも高い別のレイヤー)に `KC_TRNS` 以外のものがある場合、それが送信されるキーであり、アクティブ化したばかりのレイヤー上のキーではありません。これが、ほとんどの人の "なぜレイヤーが切り替わらないのか" 問題の原因です。

場合によっては、マクロ内あるいはタップダンスルーチンの一部としてレイヤーを切り替えたいかもしれません。`layer_on` はレイヤーをアクティブにし、`layer_off` はそれを非アクティブにします。もっと多くのレイヤーに関する関数は、[action_layer.h](https://github.com/qmk/qmk_firmware/blob/master/tmk_core/common/action_layer.h) で見つけることができます。

# 修飾キー

これらによりキーコードとモディファイアを組み合わせることができます。押すと、モディファイアのキーダウンイベントが送信され、次に `kc` のキーダウンイベントが送信されます。放すと、`kc` のキーアップイベントが送信され、次にモディファイアのキーアップイベントが送信されます。

| キー | エイリアス | 説明 |
|----------|-------------------------------|----------------------------------------------------|
| `LCTL(kc)` | `C(kc)` | 左コントロールを押しながら `kc` を押します。 |
| `LSFT(kc)` | `S(kc)` | 左シフトを押しながら `kc` を押します |
| `LALT(kc)` | `A(kc)` | 左 Alt を押しながら `kc`を押します。 |
| `LGUI(kc)` | `G(kc)`, `LCMD(kc)`, `LWIN(kc)` | 左 GUI を押しながら `kc` を押します |
| `RCTL(kc)` |  | 右コントロールを押しながら `kc` を押します。 |
| `RSFT(kc)` |  | 右シフトを押しながら `kc` を押します |
| `RALT(kc)` | `ALGR(kc)` | 右 Alt を押しながら `kc` を押します。 |
| `RGUI(kc)` | `RCMD(kc)`, `LWIN(kc)` | 右 GUI を押しながら `kc` を押します。 |
| `SGUI(kc)` | `SCMD(kc)`, `SWIN(kc)` | 左シフトと左 GUI を押しながら `kc` を押します |
| `LCA(kc)` |  | 左コントロールと左 Alt を押しながら `kc` を押します。 |
| `LCAG(kc)` |  | 左コントロール、左 Alt、左 GUI を押しながら `kc` を押します。 |
| `MEH(kc)` |  | 左コントロール、左シフトと、左 Alt を押しながら `kc` を押します。 |
| `HYPR(kc)` |  | 左コントロール、左 シフト、左 Alt、左 GUI を押しながら `kc` を押します。 |

また、それらを繋げることができます。例えば、`LCTL(LALT(KC_DEL))` は1回のキー押下で Control+Alt+Delete を送信するキーを作成します。

# Mod-Tap :id=mod-tap

Mod-Tap キー `MT(mod, kc)` は、押したままの時にモディファイアのように機能し、タップされた時に通常のキーのように振舞います。別の言い方をすると、タップした時にエスケープを送信しますが、押したままの時にコントロールあるいはシフトキーとして機能するキーを持つことができます。

このキーコードと `OSM()` を受け付けるモディファイアは、`KC_` ではなく、`MOD_` の接頭辞が付いています:

| モディファイア | 説明 |
|----------|----------------------------------------|
| `MOD_LCTL` | 左コントロール |
| `MOD_LSFT` | 左シフト |
| `MOD_LALT` | 左 Alt |
| `MOD_LGUI` | 左 GUI (Windows/Command/Meta キー) |
| `MOD_RCTL` | 右コントロール |
| `MOD_RSFT` | 右シフト |
| `MOD_RALT` | 右 Alt (AltGr) |
| `MOD_RGUI` | 右 GUI (Windows/Command/Meta キー) |
| `MOD_HYPR` | Hyper (左コントロール、シフト、Alt および GUI) |
| `MOD_MEH` | Meh (左コントロール、シフトおよび Alt) |

以下のようにそれらを Or することで、これらを組み合わせることができます:

```c
MT(MOD_LCTL | MOD_LSFT, KC_ESC)
```

押したままの時にこのキーは左コントロールおよび左シフトをアクティブにし、タップされた時にエスケープを送信します。

便宜上、QMK はキーマップで一般的な組み合わせをよりコンパクトにするために、Mod-Tap ショートカットを含んでいます:

| キー | エイリアス | 説明 |
|------------|-----------------------------------------------------------------|-------------------------------------------------------|
| `LCTL_T(kc)` | `CTL_T(kc)` | 押したままの場合は左コントロール、タップした場合は `kc` |
| `LSFT_T(kc)` | `SFT_T(kc)` | 押したままの場合は左シフト、タップした場合は `kc` |
| `LALT_T(kc)` | `ALT_T(kc)` | 押したままの場合は左 Alt、タップした場合は `kc` |
| `LGUI_T(kc)` | `LCMD_T(kc)`, `LWIN_T(kc)`, `GUI_T(kc)`, `CMD_T(kc)`, `WIN_T(kc)` | 押したままの場合は左 GUI、タップした場合は `kc` |
| `RCTL_T(kc)` |  | 押したままの場合は右コントロール、タップした場合は `kc` |
| `RSFT_T(kc)` |  | 押したままの場合は右シフト、タップした場合は `kc` |
| `RALT_T(kc)` | `ALGR_T(kc)` | 押したままの場合は右 Alt、タップした場合は `kc` |
| `RGUI_T(kc)` | `RCMD_T(kc)`, `RWIN_T(kc)` | 押したままの場合は右 GUI、タップした場合は `kc` |
| `SGUI_T(kc)` | `SCMD_T(kc)`, `SWIN_T(kc)` | 押したままの場合は左シフトと GUI、タップした場合は `kc` |
| `LCA_T(kc)` |  | 押したままの場合は左コントロールとAlt、タップした場合は `kc` |
| `LCAG_T(kc)` |  | 押したままの場合は左コントロール、Alt と GUI、タップした場合は `kc` |
| `RCAG_T(kc)` |  | 押したままの場合は右コントロール、Alt と GUI、タップした場合は `kc` |
| `C_S_T(kc)` |  | 押したままの場合は左コントロールとシフト、タップした場合は `kc` |
| `MEH_T(kc)` |  | 押したままの場合は左コントロールとシフト、タップした場合は `kc` |
| `HYPR_T(kc)` | `ALL_T(kc)` | 押したままの場合は左コントロール、シフト、Alt と GUI、タップした場合は `kc` - より詳しくは[ここ](http://brettterpstra.com/2012/12/08/a-useful-caps-lock-key/)を見てください |

## 注意事項

残念ながら、キーコードで指定されたモディファイアは無視されるため、これらのキーコードは Mod-Tap または Layer-Tap で使うことができません。

さらに、Windows でリモートディスクトップ接続を使う場合に、問題が発生する場合があります。これらのコードはシフトを非常に高速に送信するため、リモートディスクトップはコードを見逃すかもしれません。

これを修正するには、リモートディスクトップ接続を開き、"Show Options" を開き、"Local Resources" タブを開きます。キーボードセクションで、ドロップダウンを "On this Computer" に変更します。これは問題を修正し、キャラクタが正しく動作するようになります。

# ワンショットキー :id=one-shot-keys

ワンショットキーは次のキーが押されるまでアクティブのままになり、その後放されるキーです。これにより一度に1つ以上のキーを押すことなく、キーボードの組み合わせを入力することができます。これらのキーは通常 "スティッキーキー" あるいは "デッドキー" と呼ばれます。

例えば、キーを `OSM(MOD_LSFT)` と定義する場合、最初にシフトを押して放し、続いて A を押して放すことで、大文字の A キャラクタを入力することができます。コンピュータには、シフトが押された瞬間にシフトが保持され、A が放された後ですぐにシフトキーが放されるように見えます。

ワンショットキーは通常のモディファイアのようにも動作します。ワンショットキーを押しながら他のキーを入力すると、キーを放した直後にワンショットキーが解除されます。

さらに、短時間でキーを5回押すと、そのキーをロックします。これはワンショットモディファイアとワンショットレイヤーに適用され、`ONESHOT_TAP_TOGGLE` 定義によって制御されます。

`config.h` 内でこれらを定義することでワンショットキーの挙動を制御することができます:

```c
#define ONESHOT_TAP_TOGGLE 5  /* この回数をタップすると、もう一度タップするまでキーが保持されます。*/
#define ONESHOT_TIMEOUT 5000  /* ワンショットキーが解除されるまでの時間 (ms) */
```

* `OSM(mod)` - *mod*を一時的に押し続けます。[Mod Tap](#mod-tap)で示したように、`KC_*` コードでは無く、`MOD_*` キーコードを使わなければなりません。
* `OSL(layer)` - 一時的に*レイヤー*に切り替えます。

ワンショットキーをマクロあるいはタップダンスルーチンとして有効にしたい場合があります。

ワンショットレイヤーについては、キーダウン時に `set_oneshot_layer(LAYER, ONESHOT_START)` を呼び出し、キーアップ時に `clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED)` を呼び出す必要があります。ワンショットをキャンセルする場合は、`reset_oneshot_layer()` を呼んでください。

ワンショットmodについては、設定するために `set_oneshot_mods(MOD)` を呼び出し、キャンセルするために `clear_oneshot_mods()` を呼び出す必要があります。

!> リモートディスクトップ接続で OSM 変換に問題がある場合は、設定を開いて "Local Resources" タップに移動し、キーボードセクションでドロップダウンを "On this Computer" に変更することで修正することができます。これにより問題が修正され、OSM がリモートディスクトップ上で適切に動作するようになります。

## コールバック

ワンショットキーを押す時にカスタムロジックを実行したい場合、実装を選択できる幾つかのコールバックがあります。例えば、LED を点滅させたり、音を鳴らしたりして、ワンショットキーの変化を示すことができます。

`OSM(mod)` のためのコールバックがあります。ワンショット修飾キーの状態が変更されるたびに呼び出されます: オンに切り替わる時だけでなく、オフに切り替わる時にも呼び出されます。以下のように使うことができます:

```c
void oneshot_mods_changed_user(uint8_t mods) {
  if (mods & MOD_MASK_SHIFT) {
    println("Oneshot mods SHIFT");
  }
  if (mods & MOD_MASK_CTRL) {
    println("Oneshot mods CTRL");
  }
  if (mods & MOD_MASK_ALT) {
    println("Oneshot mods ALT");
  }
  if (mods & MOD_MASK_GUI) {
    println("Oneshot mods GUI");
  }
  if (!mods) {
    println("Oneshot mods off");
  }
}
```

`mods` の引数は変更後のアクティブな mod が含まれるため、現在の状態が反映されます。

(`config.h` に `#define ONESHOT_TAP_TOGGLE 2` を追加して) ワンショットタップトグルを使う場合、指定された回数だけ修飾キーを押してロックすることができます。そのためのコールバックもあります:

```c
void oneshot_locked_mods_changed_user(uint8_t mods) {
  if (mods & MOD_MASK_SHIFT) {
    println("Oneshot locked mods SHIFT");
  }
  if (mods & MOD_MASK_CTRL) {
    println("Oneshot locked mods CTRL");
  }
  if (mods & MOD_MASK_ALT) {
    println("Oneshot locked mods ALT");
  }
  if (mods & MOD_MASK_GUI) {
    println("Oneshot locked mods GUI");
  }
  if (!mods) {
    println("Oneshot locked mods off");
  }
}
```

最後に、`OSL(layer)` ワンショットキーのためのコールバックもあります:

```c
void oneshot_layer_changed_user(uint8_t layer) {
  if (layer == 1) {
    println("Oneshot layer 1 on");
  }
  if (!layer) {
    println("Oneshot layer off");
  }
}
```

いずれかのワンショットレイヤーがオフの場合、`layer` は 0 になります。ワンショットレイヤーの変更では無く、レイヤーの変更で何かを実行したい場合は、`layer_state_set_user` は使用するのに良いコールバックです。

独自のキーボードを作成している場合、`_kb` と同等の機能もあります:

```c
void oneshot_locked_mods_changed_kb(uint8_t mods);
void oneshot_mods_changed_kb(uint8_t mods);
void oneshot_layer_changed_kb(uint8_t layer);
```

他のコールバックと同様に、更にカスタマイズを可能にするために `_user` の変種を呼ぶようにしてください。

# タップホールド設定オプション

タップホールドオプションは素晴らしいですが、問題が無いわけではありません。合理的なデフォルトでそれらを設定しようとしていますが、一部の人にとってまだ問題を引き起こすかもしれません。

これらのオプションによりタップホールドキーの挙動を変更することができます。

## 許容ホールド

[PR#1359](https://github.com/qmk/qmk_firmware/pull/1359/) の時点で、新しい `config.h` オプションがあります:

```c
#define PERMISSIVE_HOLD
```

これは高速なタイピストや高い `TAPPING_TERM` 設定に対して、タップとホールドキー(Mod タップのような)動作を向上させます。

Mod タップキーを押し、他のキーをタップ(押して放す)して、Mod タップキーを放すと、全てのタッピング期間内で両方のキーの "タッピング"機能が出力されます。

例えば:

- `SFT_T(KC_A)` ダウン
- `KC_X` ダウン
- `KC_X` アップ
- `SFT_T(KC_A)` アップ

通常、これら全てを `TAPPING_TERM` (デフォルト: 200ms) 内で行うと、ファームウェアとホストシステムによって`ax` として登録されます。許容ホールドを有効にすると、別のキーがタップされた場合に Mod タップキーを Mod と見なすことで処理され、 `X` として登録されます (`SHIFT`+`x`)。

?> `Mod タップ割り込みの無視`を有効にしている場合、これにより両方の動きが変更されます。通常のキーには、最初のキーが最初に放された場合、あるいは両方のキーが `TAPPING_TERM` より長くホールドされた場合に、モディファイアが追加されます。

## Mod タイプ割り込みの無視

この設定を有効にするには、これを `config.h` に追加してください:

```c
#define IGNORE_MOD_TAP_INTERRUPT
```

許容ホールドと同様に、これは高速なタイピストのためのファームウェアの処理方法を変更します。Mod タップキーを押し、他のキーを押し、Mod タップキーを放し、通常のキーを放すと、通常は両方のキーについての "タッピング" の機能が出力されます。これはローリングコンボキーには望ましくないかもしれません。

`Mod タップ割り込みの無視`の設定には、ホールド機能 (mod) を引き起こすために `TAPPING_TERM` の両方のキーを必要とします。

例えば:

- `SFT_T(KC_A)` ダウン
- `KC_X` ダウン
- `SFT_T(KC_A)` アップ
- `KC_X` アップ

通常、これは `X` を送信します (`SHIFT`+`x`). `Mod タップ割り込みの無視`を有効にすると、ホールド アクションを登録するために、`TAPPING_TERM` に両方のキーをホールドする必要があります。この場合、高速なタップは `ax` を送信しますが、両方をホールドすると、`X`  (`SHIFT`+`x`) を出力します。


?> __注意__: これはモディファイアにのみ関係し、レイヤー切り替えキーには関係しません。

?> `許容ホールド`を有効にすると、これは両方がどのように動作するかを変更します。通常のキーには、最初のキーが最初に放された場合、あるいは両方のキーが `TAPPING_TERM` より長くホールドされた場合に、モディファイアが追加されます。

この機能をより細かく制御するために、以下を `config.h` に追加することができます:

```c
#define IGNORE_MOD_TAP_INTERRUPT_PER_KEY
```

そして、以下の関数をキーマップに追加します:

```c
bool get_ignore_mod_tap_interrupt(uint16_t keycode) {
  switch (keycode) {
    case SFT_T(KC_SPC):
      return true;
    default:
      return false;
  }
}
```

## タッピングフォースホールド

`タッピングフォースホールド` を有効にするには、以下を `config.h` に追加します:

```c
#define TAPPING_FORCE_HOLD
```

タップの後でユーザがキーをホールドすると、これは修飾キーをホールドするかわりにタップされたキーを繰り返します。これにより、タップされたキーのために自動繰り返しを使うことができます。

例:

- SFT_T(KC_A) ダウン
- SFT_T(KC_A) アップ
- SFT_T(KC_A) ダウン
- タッピング期間より長く待ちます...
- SFT_T(KC_A) アップ

デフォルトの設定では、最初のリリースで `a` が送信され、2回目の押下で `a` が送信され、コンピュータに自動リピート機能をさせることができます。

`TAPPING_FORCE_HOLD` を使うと、2回目の押下はシフトとして解釈され、それをタップして使った後ですぐにモディファイアとして使うことができます。

!> `TAPPING_FORCE_HOLD` はタッピングトグル(`TT` レイヤーのキーコード、ワンショットタッピングトグルなど)を使うものをすべて破壊します。

この機能をより細かく制御するために、以下を `config.h` に追加することができます:

```c
#define TAPPING_FORCE_HOLD_PER_KEY
```

そして、以下の関数をキーマップに追加します:

```c
bool get_tapping_force_hold(uint16_t keycode, keyrecord_t *record) {
  switch (keycode) {
    case LT(1, KC_BSPC):
      return true;
    default:
      return false;
  }
}
```

## レトロタッピング

`レトロタッピング`を有効にするには、以下のものを `config.h` に追加してください:

```c
#define RETRO_TAPPING
```

他のキーを押さずにデュアルファンクションキーを押して放しても何も起こりません。レトロタップを有効にすると、他のキーを押さずにキーを放すと、元のキーコードがタップ時間外であっても送信されます。

例えば、他のキーを押すことなく `LT(2, KC_SPACE)` を押したり放したりしても何も起こりません。これを有効にすると、代わりに `KC_SPACE` を送信します。
