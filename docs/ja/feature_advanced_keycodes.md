# 高度なキーコード

キーマップには、通常より高度なキーコードを含めることができます。例えば、押した時にレイヤを切り替えたり、修飾子を送信したりしますが、タップした時に通常のキーコードを送信します。このページは利用可能な機能を文章化します。

## カスタム名の割り当て

しばしば`#define`を使ってカスタム名を定義します。例えば:

```c
#define FN_CAPS LT(_FL, KC_CAPSLOCK)
#define ALT_TAB LALT(KC_TAB)
```

これにより、キーマップ内で`FN_CAPS` および `ALT_TAB` を使い、読みやすくします。

## 注意事項

現在のところ、`LT()` と `MT()` は [基本的なキーコードセット](keycodes_basic.md)に制限されています。つまり、`LCTL()`, `KC_TILD`あるいは`0xFF`より大きなキーコードを使うことができません。レイヤ タップあるいはModタップのキーコードの一部として指定された修飾子は無視されます。タップしたキーコードに修飾子を適用する必要がある場合は、これを達成するために[タップ ダンス](https://github.com/qmk/qmk_firmware/blob/master/docs/feature_tap_dance.md#example-5-using-tap-dance-for-advanced-mod-tap-and-layer-tap-keys)を使うことができます。

さらに、Modタップあるいはレイヤタップで少なくとも1つの右利きの修飾子が指定された場合、指定された全ての修飾子が右利きになるため、2つを組み合わせて一致させることはできません。

# レイヤのスイッチとトグル

これらの機能により、様々な方法でレイヤをアクティブ化することができます。レイヤは一般的に独立したレイアウトでは無いことに注意してください -- 複数のレイヤを一度にアクティブ化することができ、レイヤが`KC_TRNS`を使ってキーの押下を下のレイヤに渡すことが普通です。レイヤの詳細については、[キーマップの概要](keymap.md#keymap-and-layers)を見てください。MO(), LM(), TT() あるいは LT() を使って一時的なレイヤの切り替えを使う場合、上のレイヤのキーを透過的にしておくようにしてください。そうでなければ、意図したように動作しないかもしれません。

* `DF(layer)` - デフォルトのレイヤを切り替える。デフォルトのレイヤは、他のレイヤがその上に積み重なっている、常にアクティブな基本レイヤです。デフォルト レイヤの詳細については以下を見てください。これは QWERTY から Dvorak レイアウトに切り替えるために使うことができます。(これは一時的な切り替えであり、キーボードの電源が切れるまで持続することに注意していください。デフォルトのレイヤを永続的に変更するには、[process_record_user](custom_quantum_functions.md#programming-the-behavior-of-any-keycode)内で`set_single_persistent_default_layer`関数を呼び出すなど、より深いカスタマイズが必要です。)
* `MO(layer)` - 一時的に*レイヤ*をアクティブにします。キーを放すとすぐに、レイヤは非アクティブになります。
* `LM(layer, mod)` - *レイヤ* (`MO`のような)を一時的にアクティブにしますが、修飾子 *mod* がアクティブな状態です。レイヤ 0-15 と、左修飾子のみをサポートします: `MOD_LCTL`, `MOD_LSFT`, `MOD_LALT`, `MOD_LGUI` (`KC_`の代わりに`MOD_`定数を使うことに注意してください)。これらの修飾子はビット単位の OR を使って組み合わすことができます。例えば、`LM(_RAISE, MOD_LCTL | MOD_LALT)`。
* `LT(layer, kc)` - ホールドされた時に*レイヤ*を一時的にアクティブにし、タップされた時に*kc*を送信します。レイヤ 0-15 のみをサポートします。
* `OSL(layer)` - 次のキーが押されるまで、一時的に*レイヤ*をアクティブにします。詳細と追加機能については、[ワンショットキー](#one-shot-keys)を見てください。
* `TG(layer)` - *レイヤ*を切り替えます。非アクティブな場合はアクティブにし、逆も同様です。
* `TO(layer)` - *レイヤ*をアクティブにし、他の全てのレイヤ(デフォルトのレイヤを除く)を非アクティブにします。この関数は特別です。1つのレイヤをアクティブなレイヤスタックに追加/削除するだけでなく、現在のアクティブなレイヤを完全に置き換え、上位のレイヤを買いのレイヤに独自に置き換えることができるからです。これはキーダウンで(キーが押されるとすぐに)アクティブになります。
* `TT(layer)` - レイヤのタップ切り替えキーを押したままにすると、*レイヤ*がアクティブにされ、放すと非アクティブになります (`MO`のように)。繰り返しタップすると、レイヤはオンあるいはオフを切り替えます (`TG`のように)。デフォルトでは5回のタップが必要ですが、`TAPPING_TOGGLE`を定義することでこれを変更することができます -- 例えば、2回のタップだけで切り替えるには、`#define TAPPING_TOGGLE 2`。

# レイヤの使用

Care must be taken when switching layers, it's possible to lock yourself into a layer with no way to deactivate that layer (without unplugging your keyboard.) We've created some guidelines to help users avoid the most common problems.

## 初心者

QMKを使い始めたばかりの場合は、全てを単純にしたいでしょう。レイヤをセットアップする時は、これらのガイドラインに従ってください:

* デフォルトの "base" レイヤとして、layer 0 をセットアップします。これは通常の入力レイヤであり、任意のレイアウト (qwerty, dvorak, colemak など)にすることができます。通常、キーボードのキーのほとんどあるいは全てが定義されているため、これを最下位のレイヤとして設定することが重要です。つまり、もしそれが他のレイヤの上 (つまりレイヤ番号が大きい)にあるとした場合の影響を阻止します。
* レイヤ 0 をルートとして、レイヤを "ツリー" レイアウトに配置します。他の複数のレイヤから同じレイヤを入力しようとしないでください。
* レイヤのキーマップでは、より高い番号のレイヤのみを参照します。レイヤは最大の番号(最上位)のアクティブ レイヤから処理されるため、下位レイヤの状態を変更するのは難しくエラーが発生しやすくなります。

## 中級ユーザ

複数のベースレイヤが必要な場合があります。例えば、QWERTY と Dvorak を切り替える場合、国ごとに異なるレイアウトを切り替える場合、あるいは異なるビデオゲームごとにレイアウトを切り替える場合などです。ベース レイヤは常に最小の番号のレイヤである必要があります。複数のベースレイヤがある場合、常にそれらを相互排他的に扱う必要があります。1つのベースレイヤがオンの場合、他をオフにします。

## 上級ユーザ

レイヤがどのように動作し、何ができる可を理解したら、より創造的になります。初心者のセクションでリスト化されている規則は、幾つかの巧妙な詳細を回避するのに役立ちますが、特に超コンパクトなキーボードのユーザにとって制約になる場合があります。レイヤの仕組みを理解することで、レイヤをより高度な方法で使うことができます。

レイヤは番号順にお互いに重なり合っています。キーの押下の動作を決定する時に、QMKは上から順にレイヤを走査し、`KC_TRNS`に設定されていない最初のアクティブなレイヤに到達すると停止します。結果として、現在のレイヤよりも数値的に低いレイヤをアクティブにし、現在のレイヤ(あるいはアクティブでターゲットレイヤよりも高い別のレイヤ)に `KC_TRNS`以外のものがある場合、それが送信されるキーであり、アクティブ化したばかりのレイヤ上のキーではありません。これが、ほとんどの人の "なぜレイヤが切り替わらないのか" 問題の原因です。

場合によっては、マクロ内あるいはタップダンス ルーチンの一部としてレイヤを切り替えたいかもしれません。`layer_on` はレイヤをアクティブにし、`layer_off` はそれを非アクティブにします。もっと多くのレイヤに関する関数は、[action_layer.h](https://github.com/qmk/qmk_firmware/blob/master/tmk_core/common/action_layer.h)で見つけることができます。

# 修飾キー

これらのよりキーコードと修飾子を組み合わせることができます。押すと、修飾子についてのキーダウン イベントが送信され、`kc` が送信されます。放すと、`kc`についてのキーアップ イベントが送信され、修飾子が送信されます。

| キー | エイリアス | 説明 |
|----------|-------------------------------|----------------------------------------------------|
| `LCTL(kc)` | `C(kc)` | 左コントロールを押しながら `kc`を押します。 |
| `LSFT(kc)` | `S(kc)` | 左シフトを押しながら`kc`を押します |
| `LALT(kc)` | `A(kc)` | 左Altを押しながら`kc`を押します。 |
| `LGUI(kc)` | `G(kc)`, `LCMD(kc)`, `LWIN(kc)` | 左GUIを押しながら`kc`を押します |
| `RCTL(kc)` |  | 右コントロールを押しながら `kc`を押します。 |
| `RSFT(kc)` |  | 右シフトを押しながら`kc`を押します |
| `RALT(kc)` | `ALGR(kc)` | 右Altを押しながら `kc`を押します。 |
| `RGUI(kc)` | `RCMD(kc)`, `LWIN(kc)` | 右GUIを押しながら `kc`を押します。 |
| `SGUI(kc)` | `SCMD(kc)`, `SWIN(kc)` | 左シフトとGUIを押しながら`kc`を押します |
| `LCA(kc)` |  | 左コントロールとAltを押しながら`kc`を押します。 |
| `LCAG(kc)` |  | 左コントロール、AltとGUIを押しながら`kc`を押します。 |
| `MEH(kc)` |  | 左コントロール、シフトとAltを押しながら`kc`を押します。 |
| `HYPR(kc)` |  | 左コントロール、シフト、AltとGUIを押しながら`kc`を押します。 |

また、それらをチェーンすることができます。例えば、`LCTL(LALT(KC_DEL))` は1回のキー押下で Control+Alt+Delete を送信するキーを作成します。

# Mod-Tap

Mod-Tap キー `MT(mod, kc)` は、ホールドされた時に修飾子のように機能し、タップされた時に通常のキーのように振舞います。別の言い方をすると、タップした時にエスケープを送信するが、押したままの時にコントロールあるいはシフト キーとして機能するキーを持つことができます。

このキーコードと`OSM()`を受け付ける修飾子は、`KC_`ではなく、`MOD_`の接頭辞が付いています:

| 修子飾 | 説明 |
|----------|----------------------------------------|
| `MOD_LCTL` | 左コントロール |
| `MOD_LSFT` | 左シフト |
| `MOD_LALT` | 左Alt |
| `MOD_LGUI` | 左 GUI (Windows/Command/Meta キー) |
| `MOD_RCTL` | 右コントロール |
| `MOD_RSFT` | 右シフト |
| `MOD_RALT` | 右 Alt (AltGr) |
| `MOD_RGUI` | 右 GUI (Windows/Command/Meta キー) |
| `MOD_HYPR` | Hyper (左コントロール、シフト、AltおよびGUI) |
| `MOD_MEH` | Meh (左コントロール、シフトおよびAlt) |

以下のようにそれらをOrすることで、これらを組み合わせることができます:

```c
MT(MOD_LCTL | MOD_LSFT, KC_ESC)
```

ホールドされた時にこのキーは左コントロールおよび左シフトをアクティブにし、タップされた時にエスケープを送信します。

便宜上、QMKはキーマップで一般的な組み合わせをよりコンパクトにするために、Mod-Tap ショートカットを含んでいます:

| キー | エイリアス | 説明 |
|------------|-----------------------------------------------------------------|-------------------------------------------------------|
| `LCTL_T(kc)` | `CTL_T(kc)` | 左コントロールを押しながら、`kc`をタップします |
| `LSFT_T(kc)` | `SFT_T(kc)` | 左シフトを押しながら、`kc`をタップします |
| `LALT_T(kc)` | `ALT_T(kc)` | 左Altを押しながら、`kc`をタップします |
| `LGUI_T(kc)` | `LCMD_T(kc)`, `LWIN_T(kc)`, `GUI_T(kc)`, `CMD_T(kc)`, `WIN_T(kc)` | 左GUIを押しながら、`kc`をタップします |
| `RCTL_T(kc)` |  | 右コントロールを押しながら、`kc`をタップします |
| `RSFT_T(kc)` |  | 右シフトを押しながら、`kc`をタップします |
| `RALT_T(kc)` | `ALGR_T(kc)` | 右Altを押しながら、`kc`をタップします |
| `RGUI_T(kc)` | `RCMD_T(kc)`, `RWIN_T(kc)` | 右GUIを押しながら、`kc`をタップします |
| `SGUI_T(kc)` | `SCMD_T(kc)`, `SWIN_T(kc)` | 左シフトとGUIを押しながら、`kc`をタップします |
| `LCA_T(kc)` |  | 左コントロールとAltを押しながら、`kc`をタップします |
| `LCAG_T(kc)` |  | 左コントロール、AltとGUIを押しながら、`kc`をタップします |
| `RCAG_T(kc)` |  | 右コントロール、AltとGUIを押しながら、`kc`をタップします |
| `C_S_T(kc)` |  | 左コントロールとシフトを押しながら、`kc`をタップします |
| `MEH_T(kc)` |  | 左コントロールとシフトを押しながら、`kc`をタップします |
| `HYPR_T(kc)` | `ALL_T(kc)` | 左コントロール、シフト、AltとGUIを押しながら、`kc`をタップします- より詳しくは[ここ](http://brettterpstra.com/2012/12/08/a-useful-caps-lock-key/)を見てください |

## 注意事項

残念ながら、キーコードで指定された修飾子は無視されるため、これらのキーコードは Mod-Tap または Layer-Tap で使うことができません。

さらに、Windowsでリモートディスクトップ接続を使う場合に、問題が発生する場合があります。これらのコードはシフトを非常に高速に送信するため、リモートディスクトップはコードを見逃すかもしれません。

これを修正するには、リモートディスクトップ接続を開き、"Show Options"を開き、"Local Resources" タブを開きます。キーボード セクションで、ドロップダウンを "On this Computer" に変更します。これは問題を修正し、キャラクタが正しく動作するようになります。

# ワンショットキー

ワンショットキーは次のキーが押されるまでアクティブのままになり、その後放されるキーです。これにより一度に1つ以上のキーを押すことなく、キーボードの組み合わせを入力することができます。これらのキーは通常 "スティッキー キー" あるいは "デッド キー" と呼ばれます。

例えば、キーを`OSM(MOD_LSFT)`と定義する場合、最初にシフトを押して放し、続いてAを押して放すことで、大文字のAキャラクタを入力することができます。コンピュータには、シフトが押された瞬間にシフトが保持され、Aが放された後ですぐにシフトキーが放されるように見えます。

ワンショットキーは通常の修飾子のようにも動作します。ワンショットキーを押しながら他のキーを入力すると、キーを放した直後にワンショットキーが解除されます。

さらに、短期間でキーを5回押すと、そのキーをロックします。これはワンショット修飾子とワンショットレイヤに適用され、`ONESHOT_TAP_TOGGLE` 定義によって制御されます。

`config.h`内でこれらを定義することでワンショットキーの挙動を制御することができます:

```c
#define ONESHOT_TAP_TOGGLE 5  /* この回数をタップすると、もう一度タップするまでキーが保持されます。*/
#define ONESHOT_TIMEOUT 5000  /* ワンショットキーが解除されるまでの時間 (ms) */
```

* `OSM(mod)` - *mod*を一時的に押し続けます。[Mod Tap](#mod-tap)で示したように、`KC_*`コードでは無く、`MOD_*`キーコードを使わなければなりません。
* `OSL(layer)` - 一時的に*レイヤ*に切り替えます。

ワンショットキーをマクロじゃるいはタップダンス ルーチンとして有効にしたい場合があります。

ワンショットレイヤについては、キーダウン時に`set_oneshot_layer(LAYER, ONESHOT_START)`を呼び出し、キーアップ時に`set_oneshot_layer(ONESHOT_PRESSED)`を呼び出す必要があります。ワンショットをキャンセルする場合は、`reset_oneshot_layer()`を呼んでください。

ワンショットmodについては、設定するには`set_oneshot_mods(MOD)`を呼び出し、キャンセルするには`clear_oneshot_mods()`を呼び出す必要があります。

!> リモートディスクトップ接続でOSM変換に問題がある場合は、設定を開いて "ローカルリソース" タップに移動し、キーボードセクションでドロップダウンを "このコンピュータ"に変更することで修正することができます。これにより問題が修正され、OSMがリモートディスクトップ上で適切に動作するようになります。

## コールバック

ワンショットキーを押す時にカスタム ロジックを実行したい場合、実装することを選択できる幾つかのコールバックがあります。例えば、LEDを点滅させたり、音を鳴らしたりして、ワンショットキーの変化を示すことができます。

`OSM(mod)`のためのコールバックがあります。ワンショット修飾キーの状態が変更されるたびに呼び出されます: オンに切り替わる時だけでなく、オフに切り替わる時にも呼び出されます。以下のように使うことができます:

```c
void oneshot_mods_changed_user(uint8_t mods) {
  if (mods & MOD_MASK_SHIFT) {
    println("Oneshot mods SHIFT");
  }
  if (mods & MOD_MASK_CTRL) {
    println("Oneshot mods CTRL");
  }
  if (mods & MOD_MASK_ALT) {
    println("Oneshot mods ALT");
  }
  if (mods & MOD_MASK_GUI) {
    println("Oneshot mods GUI");
  }
  if (!mods) {
    println("Oneshot mods off");
  }
}
```

`mods`の引数は変更後のアクティブなmodが含まれるため、現在の状態が反映されます。

(`config.h`に`#define ONESHOT_TAP_TOGGLE 2`を追加して) ワンショットタップ トグルを使う場合、指定された回数だけ修飾キーを押してロックすることができます。そのためのコールバックもあります:

```c
void oneshot_locked_mods_changed_user(uint8_t mods) {
  if (mods & MOD_MASK_SHIFT) {
    println("Oneshot locked mods SHIFT");
  }
  if (mods & MOD_MASK_CTRL) {
    println("Oneshot locked mods CTRL");
  }
  if (mods & MOD_MASK_ALT) {
    println("Oneshot locked mods ALT");
  }
  if (mods & MOD_MASK_GUI) {
    println("Oneshot locked mods GUI");
  }
  if (!mods) {
    println("Oneshot locked mods off");
  }
}
```

最後に、`OSL(layer)` ワンショットキーのためのコールバックもあります:

```c
void oneshot_layer_changed_user(uint8_t layer) {
  if (layer == 1) {
    println("Oneshot layer 1 on");
  }
  if (!layer) {
    println("Oneshot layer off");
  }
}
```

いずれかのワンショットレイヤがオフの場合、`layer` は0になります。ワンショットレイヤの変更では無く、レイヤの変更で何かを実行したい場合は、`layer_state_set_user` が使用するのに良いコールバックです。

独自のキーボードを作成している場合、`_kb` と同等の機能もあります:

```c
void oneshot_locked_mods_changed_kb(uint8_t mods);
void oneshot_mods_changed_kb(uint8_t mods);
void oneshot_layer_changed_kb(uint8_t layer);
```

他のコールバックと同様に、更にカスタマイズを可能にするために`_user`の変種を呼ぶようにしてください。

# タップ ホールド設定オプション

タップ ホールド オプションは素晴らしいですが、問題が無いわけではありません。合理的なデフォルトでそれらを設定しようとしましたが、一部の人にとってまだ問題を引き起こすかもしれません。

これらのオプションによりタップ ホールド キーの挙動を変更することができます。

## 許容ホールド

[PR#1359](https://github.com/qmk/qmk_firmware/pull/1359/)の時点で、新しい`config.h`オプションがあります:

```c
#define PERMISSIVE_HOLD
```

これは高速のタイピストや高い`TAPPING_TERM`設定に対して、タップとホールドキー(Modタップのような)動作を向上させます。

Modタップキーを押し、他のキーをタップ(押して放す)して、Modタップキーを放すと、全てのタッピング期間内で両方のキーの "タッピング"機能が出力されます。

例えば:

- `SFT_T(KC_A)` ダウン
- `KC_X` ダウン
- `KC_X` アップ
- `SFT_T(KC_A)` アップ

通常、これら全てを`TAPPING_TERM` (デフォルト: 200ms) 内で行うと、ファームウェアとホストシステムによって`ax` として登録されます。許容ホールドを有効にすると、別のキーがタップされた場合にModタップキーをModと見なすことで処理され、`X`として登録されます (`SHIFT`+`x`)。

?> `Modタップ割り込みを無視する`を有効にしている場合、これにより両方の動きが変更されます。通常のキーには、最初のキーが最初に放された場合、あるいは両方のキーが`TAPPING_TERM`より長くホールドされた場合に、修飾子が追加されます。

## Modタイプ割り込みの無視

この設定を有効にするには、これを`config.h`に追加してください:

```c
#define IGNORE_MOD_TAP_INTERRUPT
```

許容ホールドと同様に、これは高速なタイピストのためのファームウェアの処理方法を変更します。Modタップキーを押し、他のキーを押し、Modタップキーを放し、通常のキーを放すと、通常は両方のキーについての "タッピング" の機能が出力されます。これはローリング コンボ キーには望ましくないかもしれません。

`Modタップ割り込みの無視`の設定には、ホールド機能(mod)を引き起こすために`TAPPING_TERM` の両方のキーを必要とします。

例えば:

- `SFT_T(KC_A)` ダウン
- `KC_X` ダウン
- `SFT_T(KC_A)` アップ
- `KC_X` アップ

通常、これは`X`を送信します (`SHIFT`+`x`). `Modタップ割り込みの無視`を有効にすると、ホールド アクションを登録するために、`TAPPING_TERM` に両方のキーをホールドする必要があります。この場合、高速なタップは`ax` を送信しますが、両方をホールドすると、`X`  (`SHIFT`+`x`) を出力します。


?> __注意__: これは修飾子にのみ関係し、レイヤ切り替えキーには関係しません。

?> `許容ホールド`を有効にすると、これは両方がどのように動作するかを変更します。通常のキーには、最初のキーが最初に放された場合、あるいは両方のキーが`TAPPING_TERM`より長くホールドされた場合に、修飾子が追加されます。

## タッピング フォース ホールド

`tapping force hold`を有効にするには、以下を`config.h`に追加します:

```c
#define TAPPING_FORCE_HOLD
```

タップの後でユーザがキーをホールドすると、これは修飾キーをホールドするかわりにタップされたキーを繰り返します。これにより、タップされたキーのために自動繰り返しを使うことができます。

例:

- SFT_T(KC_A) ダウン
- SFT_T(KC_A) アップ
- SFT_T(KC_A) ダウン
- wait more than tapping term...
- SFT_T(KC_A) アップ

デフォルトの設定では、最初のリリースで`a` が送信され、2回目の押下で`a` が送信され、コンピュータが自動リピート機能を引き起こすことができます。

`TAPPING_FORCE_HOLD`を使うと、2回目の押下はシフトとして解釈され、それをタップして使った後ですぐに修飾子として使うことができます。

!> `TAPPING_FORCE_HOLD` は(`TT` レイヤのキーコード、ワンショット タッピング トグルなど)を使うものをすべて破壊します。

## レトロ タッピング

`レトロ タッピング`を有効にするには、以下のものを`config.h`に追加してください:

```c
#define RETRO_TAPPING
```

他のキーを押さずにデュアルファンクションキーを押して放しても何も起こりません。レトロタップを有効にすると、他のキーを押さずにキーを放すと、元のキーコードがタップ時間外であっても送信されます。

例えば、他のキーを押すことなく`LT(2, KC_SPACE)`を押したり話したりしても何も起こりません。これを有効にすると、代わりに`KC_SPACE`を送信します。
