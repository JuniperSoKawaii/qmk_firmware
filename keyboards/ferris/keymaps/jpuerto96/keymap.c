#include QMK_KEYBOARD_H

/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

#define _BASE 0
#define _RAISE 1
#define _LOWER 2

// Fillers to make layering more clear

// Left-hand HR Mods
#define ALT_A ALT_T(KC_A)
#define GUI_S GUI_T(KC_S)
#define SFT_D SFT_T(KC_D)
#define CTL_F CTL_T(KC_F)

// Right-hand HR Mods
#define CTL_J  CTL_T(KC_J)
#define SFT_K  SFT_T(KC_K)
#define GUI_L  GUI_T(KC_L)
#define ALT_SC ALT_T(KC_SCLN)

#define ____ KC_TRNS

#define RAISE MO(_RAISE)
#define LOWER MO(_LOWER)

typedef enum {
    TD_NONE,
    TD_UNKNOWN,
    TD_SINGLE_TAP,
    TD_SINGLE_HOLD,
} td_state_t;

typedef struct {
    bool is_press_action;
    td_state_t state;
} td_tap_t;

// Tap dance enums
enum {
    Q_ESC,
    G_TAB,
    H_BSPC
};

td_state_t cur_dance(qk_tap_dance_state_t *state);

// For the x tap dance. Put it here so it can be used in any keymap
void q_finished(qk_tap_dance_state_t *state, void *user_data);
void q_reset(qk_tap_dance_state_t *state, void *user_data);
void g_finished(qk_tap_dance_state_t *state, void *user_data);
void g_reset(qk_tap_dance_state_t *state, void *user_data);
void h_finished(qk_tap_dance_state_t *state, void *user_data);
void h_reset(qk_tap_dance_state_t *state, void *user_data);

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {

/* Base (qwerty)
 * ,----------------------------------,                             ,----------------------------------,
 * |   q  |   w  |   e  |   r  |   t  |                             |   y  |   u  |   i  |   o  |   p  |
 * |------+------+------+------+------|                             |-------------+------+------+------|
 * |   a  |   s  |   d  |   f  |   g  |                             |   h  |   j  |   k  |   l  |   ;  |
 * |------+------+------+------+------|                             |------|------+------+------+------|
 * |   z  |   x  |   c  |   v  |   b  |                             |   n  |   m  |   ,  |   .  |   /  |
 * |------+------+------+-------------,                             ,-------------+------+------+------,
 *                      |LOWER | SPC  |                             |ENT   | RAISE|
 *                      '-------------'                             '-------------'
 */

[_BASE] = LAYOUT( \
  TD(Q_ESC), KC_W, KC_E,    KC_R,    KC_T,                                       KC_Y, KC_U,    KC_I,    KC_O,   KC_P,    \
  ALT_A, GUI_S, SFT_D, CTL_F,    TD(G_TAB),                                      TD(H_BSPC), CTL_J,   SFT_K,   GUI_L,  ALT_SC, \
  KC_Z, KC_X, KC_C,    KC_V,    KC_B,                                       KC_N, KC_M,    KC_COMM, KC_DOT, KC_SLSH, \
                       LOWER, KC_SPC,                                       KC_ENT,   RAISE \
),
/* Raise
 * ,----------------------------------,                             ,----------------------------------,
 * |  !   |  @   |  #   |  $   |  %   |                             | ^    |  &   | *    |  (   | )    |
 * |------+------+------+------+------|                             |-------------+------+------+------|
 * |  F1  | F2   | F3   | F4   |  F5  |                             | -    | =    | {    | }    |  '   |
 * |------+------+------+------+------|                             |------|------+------+------+------|
 * |  F6  |  F7  | F8   | F9   |  F10 |                             | _    |  +   |  [   |  ]   |  \   |
 * |------+------+------+-------------,                             ,-------------+------+------+------,
 *                      |      |      |                             |      |      |
 *                      '-------------'                             '-------------'
 */

[_RAISE] = LAYOUT( \
  KC_EXLM, KC_AT, KC_HASH, KC_DLR, KC_PERC,                   KC_CIRC, KC_AMPR, KC_ASTR, KC_LPRN, KC_RPRN,   \
  KC_F1,   KC_F2, KC_F3,   KC_F4,  KC_F5,                     KC_MINS, KC_EQL,  KC_LCBR, KC_RCBR, KC_QUOT, \
  KC_F6,   KC_F7, KC_F8,   KC_F9,  KC_F10,                    KC_UNDS, KC_PLUS, KC_LBRC, KC_RBRC, KC_BSLS, \
                            ____,    ____,                      ____,    ____              \
),

/* Lower
 * ,----------------------------------,                             ,----------------------------------,
 * |  1   |  2   |  3   |  4   |  5   |                             |   6  |  7   |   8  |   9  |    0 |
 * |------+------+------+------+------|                             |-------------+------+------+------|
 * |  |   |  `   |  ~   |      |      |                             |      |  lt  |  dn  |  up  |  rt  |
 * |------+------+------+------+------|                             |------|------+------+------+------|
 * |      |      |      |      |      |                             |      |      |      |      |      |
 * |------+------+------+-------------,                             ,-------------+------+------+------,
 *                      |      |      |                             |      |      |
 *                      '-------------'                             '-------------'
 */

[_LOWER] = LAYOUT( \
  KC_1,    KC_2,   KC_3,    KC_4,   KC_5,                     KC_6,    KC_7,     KC_8,    KC_9,    KC_0,    \
  KC_PIPE, KC_GRV, KC_TILD, ____,   ____,                     ____,    KC_LEFT,    KC_DOWN,   KC_UP,   KC_RGHT, \
  ____,    ____,   ____,    ____,   ____,                     ____,    ____,     ____,    ____,    ____, \
                           ____,    ____,                     ____,    ____        \
)

};

/* Return an integer that corresponds to what kind of tap dance should be executed.
 *
 * How to figure out tap dance state: interrupted and pressed.
 *
 * Interrupted: If the state of a dance dance is "interrupted", that means that another key has been hit
 *  under the tapping term. This is typically indicitive that you are trying to "tap" the key.
 *
 * Pressed: Whether or not the key is still being pressed. If this value is true, that means the tapping term
 *  has ended, but the key is still being pressed down. This generally means the key is being "held".
 *
 * One thing that is currenlty not possible with qmk software in regards to tap dance is to mimic the "permissive hold"
 *  feature. In general, advanced tap dances do not work well if they are used with commonly typed letters.
 *  For example "A". Tap dances are best used on non-letter keys that are not hit while typing letters.
 *
 * Good places to put an advanced tap dance:
 *  z,q,x,j,k,v,b, any function key, home/end, comma, semi-colon
 *
 * Criteria for "good placement" of a tap dance key:
 *  Not a key that is hit frequently in a sentence
 *  Not a key that is used frequently to double tap, for example 'tab' is often double tapped in a terminal, or
 *    in a web form. So 'tab' would be a poor choice for a tap dance.
 *  Letters used in common words as a double. For example 'p' in 'pepper'. If a tap dance function existed on the
 *    letter 'p', the word 'pepper' would be quite frustating to type.
 *
 * For the third point, there does exist the 'TD_DOUBLE_SINGLE_TAP', however this is not fully tested
 *
 */
td_state_t cur_dance(qk_tap_dance_state_t *state) {
    if (state->count == 1) {
        if (state->interrupted || !state->pressed) return TD_SINGLE_TAP;
        // Key has not been interrupted, but the key is still held. Means you want to send a 'HOLD'.
        else return TD_SINGLE_HOLD;
    }
    else return TD_UNKNOWN;
}

// Create an instance of 'td_tap_t' for the 'x' tap dance.
static td_tap_t qtap_state = {
    .is_press_action = true,
    .state = TD_NONE
};

void q_finished(qk_tap_dance_state_t *state, void *user_data) {
    qtap_state.state = cur_dance(state);
    switch (qtap_state.state) {
        case TD_SINGLE_TAP: register_code(KC_Q); break;
        case TD_SINGLE_HOLD: register_code(KC_ESC); break;
        default: break;
        // Last case is for fast typing. Assuming your key is `f`:
        // For example, when typing the word `buffer`, and you want to make sure that you send `ff` and not `Esc`.
        // In order to type `ff` when typing fast, the next character will have to be hit within the `TAPPING_TERM`, which by default is 200ms.
    }
}

void q_reset(qk_tap_dance_state_t *state, void *user_data) {
    switch (qtap_state.state) {
        case TD_SINGLE_TAP: unregister_code(KC_Q); break;
        case TD_SINGLE_HOLD: unregister_code(KC_ESC); break;
        default: break;
    }
    qtap_state.state = TD_NONE;
}

static td_tap_t gtap_state = {
	.is_press_action= true,
	.state = TD_NONE
};

void g_finished(qk_tap_dance_state_t *state, void *user_data) {
    gtap_state.state = cur_dance(state);
    switch (gtap_state.state) {
        case TD_SINGLE_TAP: register_code(KC_G); break;
        case TD_SINGLE_HOLD: register_code(KC_TAB); break;
        default: break;
        // Last case is for fast typing. Assuming your key is `f`:
        // For example, when typing the word `buffer`, and you want to make sure that you send `ff` and not `Esc`.
        // In order to type `ff` when typing fast, the next character will have to be hit within the `TAPPING_TERM`, which by default is 200ms.
    }
}

void g_reset(qk_tap_dance_state_t *state, void *user_data) {
    switch (gtap_state.state) {
        case TD_SINGLE_TAP: unregister_code(KC_G); break;
        case TD_SINGLE_HOLD: unregister_code(KC_TAB); break;
        default: break;
    }
    gtap_state.state = TD_NONE;
}

static td_tap_t htap_state = {
        .is_press_action= true,
        .state = TD_NONE
};

void h_finished(qk_tap_dance_state_t *state, void *user_data) {
    htap_state.state = cur_dance(state);
    switch (htap_state.state) {
        case TD_SINGLE_TAP: register_code(KC_H); break;
        case TD_SINGLE_HOLD: register_code(KC_BSPC); break;
        default: break;
        // Last case is for fast typing. Assuming your key is `f`:
        // For example, when typing the word `buffer`, and you want to make sure that you send `ff` and not `Esc`.
        // In order to type `ff` when typing fast, the next character will have to be hit within the `TAPPING_TERM`, which by default is 200ms.
    }
}

void h_reset(qk_tap_dance_state_t *state, void *user_data) {
    switch (htap_state.state) {
        case TD_SINGLE_TAP: unregister_code(KC_H); break;
        case TD_SINGLE_HOLD: unregister_code(KC_BSPC); break;
        default: break;
    }
    gtap_state.state = TD_NONE;
}

qk_tap_dance_action_t tap_dance_actions[] = {
    [Q_ESC] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, q_finished, q_reset),
    [G_TAB] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, g_finished, g_reset),
    [H_BSPC] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, h_finished, h_reset)
};
