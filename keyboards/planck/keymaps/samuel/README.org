#+Title: Samuel's Literate QMK Config
#+PROPERTY: header-args :tangle ~/qmk_firmware/keyboards/planck/keymaps/samuel/keymap.c

This is my qmk firmware for my keyboard. I grew tired of organizing the keycode
array in plain text so I made it a literate .org file. I've never done this
before, so bear with me.

* Keymap

TODO qwerty layer

#+BEGIN_COMMENT
#+NAME: empty-layer
| <6>    | <6>    | <6>    | <6>    | <6>    | <6>    | <6>    | <6>    | <6>    | <6>    | <6>    | <6>    |
|--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------|
| -      | -      | -      | -      | -      | -      | -      | -      | -      | -      | -      | -      |
| -      | -      | -      | -      | -      | -      | -      | -      | -      | -      | -      | -      |
| -      | -      | -      | -      | -      | -      | -      | -      | -      | -      | -      | -      |
| -      | -      | -      | -      | -      | -      | -      | -      | -      | -      | -      | -      |
|--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------|
#+END_COMMENT

This is my "pretty" org mode organized table for my main dvorak layer. If you
don't use org mode, it won't be that exiting, but if you enjoy working in org
mode, you can edit this table directly, and this file is tangled to the actual
keymap. No more organizing spaces or converting to and from comments.

#+NAME: home-layer
|--------+--------+------+------+------+-----+-----+-----+------+-------+--------+--------|
| T_LRSE | QUOT   | COMM | DOT  | P    | Y   | F   | G   | C    | R     | L      | T_RRSE |
| T_LSFT | A      | O    | E    | U    | I   | D   | H   | T    | N     | S      | T_RSFT |
| T_LCTL | SCLN   | Q    | J    | K    | X   | B   | M   | W    | V     | Z      | T_RCTL |
| T_LGUI | T_LALT | UP   | DOWN | BSPC | TAB | ENT | SPC | LEFT | RIGHT | T_RALT | T_RGUI |
|--------+--------+------+------+------+-----+-----+-----+------+-------+--------+--------|

I tried to keep my layout bare bones, just what would be available on a normal
keyboard, minus some keys I never used. The bottom left copies a normal
keyboards symbols from shifted numbers, and the rest is placed where convenient,
with some considerations for one handed use, hence the shortcuts in the top left.

#+NAME: secondary-layer
|----+--------+--------+--------+--------+------+------+----+--------+--------+-----+----|
| -- | EZUNDO | EZCOPY | EZCUT  | EZPSTE | INS  | EQL  |  7 |      8 |      9 | F11 | -- |
| -- | ESC    | CAPS   | PGUP   | PGDN   | F4   | ASTR |  4 |      5 |      6 | 0   | -- |
| -- | EXLM   | AT     | HASH   | DLR    | PERC | CIRC |  1 |      2 |      3 | F12 | -- |
| -- | --     | EZUP   | EZDOWN | --     | AMPR | PIPE | -- | EZLEFT | EZRGHT | --  | -- |
|----+--------+--------+--------+--------+------+------+----+--------+--------+-----+----|

But wait, we are missing several important keys!? yes, well, the modifier keys
all do other keys when tapped. More about that in the keymap section.

* Keymap Conversion in Python

This python can convert that table into the array needed for the keymap file. It
simply prepends every key with "KC_". I used to use a dictionary to convert some
keys from the table into qmk keycodes, but the double convertion was
unneccessary so I simply prepended all my macros with KC and moved all the
implementation to the `process-user-input` function.

#+NAME:layer-to-array
#+BEGIN_SRC python :var keys=secondary-layer :tangle no
results = "{"
row = 0
while row < len(keys):
  results += '{ '
  key = 0
  while key < len(keys[row]):
    keyName = str(keys[row][key])
    if keyName == '--':
      keyName = 'TRANSPARENT'
    results += 'KC_' + keyName
    if key != 11:
      results += ', '
    key+=1
  results += '}'
  if row != 3:
    results += ','
  results += '\n'
  row+=1
results += '},\n'
return results
#+END_SRC

* keymap.c

Now that we have done all the hard work, lets layout our keymap file then define
our macros.

** Headers And Layer Declaration

#+BEGIN_SRC C :noweb yes
#include "planck.h"
#include "action_layer.h"

#define TAPPING_TERM 250

extern keymap_config_t keymap_config;

static uint16_t tap_timers[10]  = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

bool tap_interupted = false;

enum planck_layers {
  _DVORAK,
  _RISE
};

// where the 'T_' communicates how the key does something different when tapped.
enum planck_keycodes {
  DVORAK = SAFE_RANGE,
  RISE,
  KC_T_LALT,
  KC_T_RALT,
  KC_T_LGUI,
  KC_T_RGUI,
  KC_T_LCTL,
  KC_T_RCTL,
  KC_T_LSFT,
  KC_T_RSFT,
  KC_T_LRSE,
  KC_T_RRSE,
  KC_EZRGHT,
  KC_EZLEFT,
  KC_EZUP,
  KC_EZDOWN,
  KC_EZUNDO,
  KC_EZCOPY,
  KC_EZCUT,
  KC_EZPSTE
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {

#+END_SRC

** Import Key table

#+BEGIN_SRC C :noweb yes
[_DVORAK] =

#+END_SRC

#+BEGIN_SRC C :noweb yes
<<layer-to-array(home-layer)>>

#+END_SRC

#+BEGIN_SRC C :noweb yes
[_RISE] =

#+END_SRC

#+BEGIN_SRC C :noweb yes
<<layer-to-array(secondary-layer)>>

#+END_SRC

** Process User Input
*** Basics

Method I copied for easily typing modified keys like parantheses

#+BEGIN_SRC C :noweb yes
};

void mod_type(uint16_t modcode, uint16_t keycode) {
  register_mods(MOD_BIT(modcode));
  register_code(keycode);
  unregister_code(keycode);
  unregister_mods(MOD_BIT(modcode));
}

#+END_SRC

The function that filter's user inputs and applies macros, the begginning is
pretty basic, setting our main layer and configuring our secondary layer.

#+BEGIN_SRC C :noweb yes
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
  switch (keycode) {
    case DVORAK:
      if (record->event.pressed) {
        set_single_persistent_default_layer(_DVORAK);
      }
      return false;
      break;
    case RISE:
      if (record->event.pressed) {
        layer_on(_RISE);
      } else {
        layer_off(_RISE);
      }
      return false;
      break;

#+END_SRC

*** Alt  and ()

Left and right alt are ( and ) when tapped. I put them on alt instead of a more
conveniant key like control because parentheses do not need to be shift modified
ever, unlike some other tap keys seen in the next sections.

#+BEGIN_SRC C :noweb yes
case KC_T_LALT:
if (record->event.pressed) {
  tap_timers[0] = timer_read();
  tap_interupted = false;
  register_mods(MOD_BIT(KC_LALT));
 } else {
  unregister_mods(MOD_BIT(KC_LALT));
  if (!tap_interupted && timer_elapsed(tap_timers[0]) < TAPPING_TERM) {
    mod_type(KC_LSHIFT, KC_9);
    tap_interupted = true;
  }
 }
return false;
break;
case KC_T_RALT:
if (record->event.pressed) {
  tap_timers[1] = timer_read();
  tap_interupted = false;
  register_mods(MOD_BIT(KC_RALT));
 } else {
  unregister_mods(MOD_BIT(KC_RALT));
  if (!tap_interupted && timer_elapsed(tap_timers[1]) < TAPPING_TERM) {
    mod_type(KC_LSHIFT, KC_0);
    tap_interupted = true;
  }
 }
return false;
break;

#+END_SRC

*** Gui  and `\

I place gui in the bottom corner because I believe it is the hardest key to
reach, so gui seemed like a good fit for a dedicated key that I never want to
have to spam. For tap keys, I used equally unused keys that are not apart of the
number pad or shifted number keys.

#+BEGIN_SRC C :noweb yes
case KC_T_LGUI:
if (record->event.pressed) {
  tap_timers[2] = timer_read();
  tap_interupted = false;
  register_mods(MOD_BIT(KC_LGUI));
 } else {
  unregister_mods(MOD_BIT(KC_LGUI));
  if (!tap_interupted && timer_elapsed(tap_timers[2]) < TAPPING_TERM) {
    SEND_STRING(SS_TAP(X_GRAVE));
    tap_interupted = true;
  }
 }
return false;
break;
case KC_T_RGUI:
if (record->event.pressed) {
  tap_timers[3] = timer_read();
  tap_interupted = false;
  register_mods(MOD_BIT(KC_RGUI));
 } else {
  unregister_mods(MOD_BIT(KC_RGUI));
  if (!tap_interupted && timer_elapsed(tap_timers[3]) < TAPPING_TERM) {
    SEND_STRING(SS_TAP(X_BSLASH));
    tap_interupted = true;
  }
 }
return false;
break;

#+END_SRC

*** Ctrl and []

Left and right control are [] respectively when they are tapped, making { and }
also very convenient.

#+BEGIN_SRC C :noweb yes
case KC_T_LCTL:
if (record->event.pressed) {
  tap_timers[4] = timer_read();
  tap_interupted = false;
  register_mods(MOD_BIT(KC_LCTL));
 } else {
  unregister_mods(MOD_BIT(KC_LCTL));
  if (!tap_interupted && timer_elapsed(tap_timers[4]) < TAPPING_TERM) {
    SEND_STRING(SS_TAP(X_LBRACKET));
    tap_interupted = true;
  }
 }
return false;
break;
case KC_T_RCTL:
if (record->event.pressed) {
  tap_timers[5] = timer_read();
  tap_interupted = false;
  register_mods(MOD_BIT(KC_RCTL));
 } else {
  unregister_mods(MOD_BIT(KC_RCTL));
  if (!tap_interupted && timer_elapsed(tap_timers[5]) < TAPPING_TERM) {
    SEND_STRING(SS_TAP(X_RBRACKET));
    tap_interupted = true;
  }
 }
return false;
break;

#+END_SRC

*** Shft and =-

I place shift on the home row, so having '-' right of my pinkie is standard, and
it only felt natural to put its opposite, '=/+' on the other side.

#+BEGIN_SRC C :noweb yes
case KC_T_LSFT:
if (record->event.pressed) {
  tap_timers[6] = timer_read();
  tap_interupted = false;
  register_mods(MOD_BIT(KC_LSFT));
 } else {
  unregister_mods(MOD_BIT(KC_LSFT));
  if (!tap_interupted && timer_elapsed(tap_timers[6]) < TAPPING_TERM) {
    SEND_STRING(SS_TAP(X_EQUAL));
    tap_interupted = true;
  }
 }
return false;
break;
case KC_T_RSFT:
if (record->event.pressed) {
  tap_timers[7] = timer_read();
  tap_interupted = false;
  register_mods(MOD_BIT(KC_RSFT));
 } else {
  unregister_mods(MOD_BIT(KC_RSFT));
  if (!tap_interupted && timer_elapsed(tap_timers[7]) < TAPPING_TERM) {
    SEND_STRING(SS_TAP(X_MINUS));
    tap_interupted = true;
  }
 }
return false;
break;

#+END_SRC

*** RISE and DEL and /

I use the top corners as rise because I decided that I do not like using layers
with my thumbs. It feels uncomfortable to hold by thumbs there, and only like to
tap with my thumbs. I pinky is for holding modifiers, so it makes sense to put
the layer key with the other modifiers. Both my left and right layer keys
activate the same layer which also makes sense to me. You wouldn't want left and
right shift to do different things.

I used to have escape in the top left, but I use delete a lot more, and putting
escape under a layer has not been a problem at all. I put / in the top right
corner again mimicing a standard dvorak keyboard.

#+BEGIN_SRC C :noweb yes
case KC_T_LRSE:
if (record->event.pressed) {
  tap_timers[8] = timer_read();
  tap_interupted = false;
  layer_on(_RISE);
 } else {
  layer_off(_RISE);
  if (!tap_interupted && timer_elapsed(tap_timers[8]) < TAPPING_TERM) {
    SEND_STRING(SS_TAP(X_DELETE));
    tap_interupted = true;
  }
 }
return false;
break;
case KC_T_RRSE:
if (record->event.pressed) {
  tap_timers[9] = timer_read();
  tap_interupted = false;
  layer_on(_RISE);
 } else {
  layer_off(_RISE);
  if (!tap_interupted && timer_elapsed(tap_timers[9]) < TAPPING_TERM) {
    SEND_STRING(SS_TAP(X_SLASH));
    tap_interupted = true;
  }
 }
return false;
break;

#+END_SRC

*** EZ keys

I use ctrl+shift+arrows keys a lot, so when the layer key is pressed they became
lazy versions of themselves with control and shift already pressed.

I also added undo, copy, paste, and cut to be easily available with only the
left hand like on a qwerty or colemek keyboard.

#+BEGIN_SRC C :noweb yes
case KC_EZRGHT:
if (record->event.pressed) {
  mod_type(LCTL(KC_LSHIFT), KC_RGHT);
 }
return false;
break;
case KC_EZLEFT:
if (record->event.pressed) {
  mod_type(LCTL(KC_LSHIFT), KC_LEFT);
 }
return false;
break;
case KC_EZDOWN:
if (record->event.pressed) {
  mod_type(LCTL(KC_LSHIFT), KC_DOWN);
 }
return false;
break;
case KC_EZUP:
if (record->event.pressed) {
  mod_type(LCTL(KC_LSHIFT), KC_UP);
 }
return false;
break;
case KC_EZUNDO:
if (record->event.pressed) {
  mod_type(KC_LCTL, KC_Z);
}
return false;
break;
case KC_EZCOPY:
if (record->event.pressed) {
  mod_type(KC_LCTL, KC_C);
}
return false;
break;
case KC_EZCUT:
if (record->event.pressed) {
  mod_type(KC_LCTL, KC_X);
}
return false;
break;
case KC_EZPSTE:
if (record->event.pressed) {
  mod_type(KC_LCTL, KC_V);
}
return false;
break;
#+END_SRC

*** Standard inputs interupt tap

Finally, if just a standard key is tapped, set the interupted flag.

#+BEGIN_SRC C :noweb yes
  }
  tap_interupted = true;
  return true;
}
#+END_SRC
