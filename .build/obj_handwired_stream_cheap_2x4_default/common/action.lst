   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB108:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:tmk_core/common/action.c **** #    include "pointing_device.h"
  42:tmk_core/common/action.c **** #endif
  43:tmk_core/common/action.c **** 
  44:tmk_core/common/action.c **** int tp_buttons;
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  51:tmk_core/common/action.c **** #    include "fauxclicky.h"
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  55:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** 
  58:tmk_core/common/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  59:tmk_core/common/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  60:tmk_core/common/action.c **** #endif
  61:tmk_core/common/action.c **** 
  62:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  63:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  64:tmk_core/common/action.c **** #endif
  65:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  66:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  67:tmk_core/common/action.c **** #endif
  68:tmk_core/common/action.c **** /** \brief Called to execute an action.
  69:tmk_core/common/action.c ****  *
  70:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  71:tmk_core/common/action.c ****  */
  72:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 72 36 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  73:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 73 5 view .LVU1
  74:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  75:tmk_core/common/action.c ****         dprint("EVENT: ");
  76:tmk_core/common/action.c ****         debug_event(event);
  77:tmk_core/common/action.c ****         dprintln();
  49               		.loc 1 77 19 view .LVU2
  78:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  79:tmk_core/common/action.c ****         retro_tapping_counter++;
  80:tmk_core/common/action.c **** #endif
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c **** 
  83:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  84:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  85:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  86:tmk_core/common/action.c ****     }
  87:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  88:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  89:tmk_core/common/action.c ****     }
  90:tmk_core/common/action.c ****     fauxclicky_check();
  91:tmk_core/common/action.c **** #endif
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  94:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  95:tmk_core/common/action.c ****         process_hand_swap(&event);
  96:tmk_core/common/action.c ****     }
  97:tmk_core/common/action.c **** #endif
  98:tmk_core/common/action.c **** 
  99:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  50               		.loc 1 99 5 view .LVU3
  51               		.loc 1 99 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
 100:tmk_core/common/action.c **** 
 101:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 102:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
 103:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
 104:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 105:tmk_core/common/action.c ****     }
 106:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
 107:tmk_core/common/action.c ****         clear_oneshot_mods();
 108:tmk_core/common/action.c ****     }
 109:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 110:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 111:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 112:tmk_core/common/action.c ****     }
 113:tmk_core/common/action.c **** #        endif
 114:tmk_core/common/action.c **** #    endif
 115:tmk_core/common/action.c **** #endif
 116:tmk_core/common/action.c **** 
 117:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 118:tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 118 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 118 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 118 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
 119:tmk_core/common/action.c **** #else
 120:tmk_core/common/action.c ****     process_record(&record);
 121:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 122:tmk_core/common/action.c ****         dprint("processed: ");
 123:tmk_core/common/action.c ****         debug_record(record);
 124:tmk_core/common/action.c ****         dprintln();
 125:tmk_core/common/action.c ****     }
 126:tmk_core/common/action.c **** #endif
 127:tmk_core/common/action.c **** }
  76               		.loc 1 127 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
 118:tmk_core/common/action.c **** #else
  85               		.loc 1 118 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE108:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB110:
 128:tmk_core/common/action.c **** 
 129:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 130:tmk_core/common/action.c **** bool swap_hands = false;
 131:tmk_core/common/action.c **** bool swap_held  = false;
 132:tmk_core/common/action.c **** 
 133:tmk_core/common/action.c **** /** \brief Process Hand Swap
 134:tmk_core/common/action.c ****  *
 135:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 136:tmk_core/common/action.c ****  */
 137:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 138:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 139:tmk_core/common/action.c **** 
 140:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 141:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 142:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 143:tmk_core/common/action.c **** 
 144:tmk_core/common/action.c ****     if (do_swap) {
 145:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 146:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 147:tmk_core/common/action.c ****     } else {
 148:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 149:tmk_core/common/action.c ****     }
 150:tmk_core/common/action.c **** }
 151:tmk_core/common/action.c **** #endif
 152:tmk_core/common/action.c **** 
 153:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 154:tmk_core/common/action.c **** bool disable_action_cache = false;
 155:tmk_core/common/action.c **** 
 156:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 157:tmk_core/common/action.c ****     disable_action_cache = true;
 158:tmk_core/common/action.c ****     process_record(record);
 159:tmk_core/common/action.c ****     disable_action_cache = false;
 160:tmk_core/common/action.c **** }
 161:tmk_core/common/action.c **** #else
 162:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 163:tmk_core/common/action.c **** #endif
 164:tmk_core/common/action.c **** 
 165:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  97               		.loc 1 165 72 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 103               		.loc 1 165 74 view .LVU11
 104               		.loc 1 165 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 165 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE110:
 113               		.section	.text.post_process_record_quantum,"ax",@progbits
 114               		.weak	post_process_record_quantum
 116               	post_process_record_quantum:
 117               	.LVL6:
 118               	.LFB111:
 166:tmk_core/common/action.c **** 
 167:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 119               		.loc 1 167 77 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 125               		.loc 1 167 78 view .LVU15
 126               	/* epilogue start */
 127               		.loc 1 167 1 is_stmt 0 view .LVU16
 128 0000 0895      		ret
 129               		.cfi_endproc
 130               	.LFE111:
 132               		.section	.text.process_record_tap_hint,"ax",@progbits
 133               	.global	process_record_tap_hint
 135               	process_record_tap_hint:
 136               	.LVL7:
 137               	.LFB112:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 170:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 171:tmk_core/common/action.c ****  *
 172:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 173:tmk_core/common/action.c ****  */
 174:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 138               		.loc 1 174 51 is_stmt 1 view -0
 139               		.cfi_startproc
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 175:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 144               		.loc 1 175 5 view .LVU18
 145               		.loc 1 175 23 is_stmt 0 view .LVU19
 146 0000 FC01      		movw r30,r24
 147 0002 8081      		ld r24,Z
 148 0004 9181      		ldd r25,Z+1
 149               	.LVL8:
 150               		.loc 1 175 23 view .LVU20
 151 0006 0C94 0000 		jmp layer_switch_get_action
 152               	.LVL9:
 153               		.loc 1 175 23 view .LVU21
 154               		.cfi_endproc
 155               	.LFE112:
 157               		.section	.text.register_code,"ax",@progbits
 158               	.global	register_code
 160               	register_code:
 161               	.LVL10:
 162               	.LFB116:
 176:tmk_core/common/action.c **** 
 177:tmk_core/common/action.c ****     switch (action.kind.id) {
 178:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 179:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 180:tmk_core/common/action.c ****             switch (action.swap.code) {
 181:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 182:tmk_core/common/action.c ****                     break;
 183:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 184:tmk_core/common/action.c ****                 default:
 185:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 186:tmk_core/common/action.c ****                     swap_held  = true;
 187:tmk_core/common/action.c ****             }
 188:tmk_core/common/action.c ****             break;
 189:tmk_core/common/action.c **** #    endif
 190:tmk_core/common/action.c ****     }
 191:tmk_core/common/action.c **** }
 192:tmk_core/common/action.c **** #endif
 193:tmk_core/common/action.c **** 
 194:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 195:tmk_core/common/action.c ****  *
 196:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 197:tmk_core/common/action.c ****  */
 198:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 199:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 200:tmk_core/common/action.c ****         return;
 201:tmk_core/common/action.c ****     }
 202:tmk_core/common/action.c **** 
 203:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 204:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 205:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 206:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 207:tmk_core/common/action.c ****         }
 208:tmk_core/common/action.c **** #endif
 209:tmk_core/common/action.c ****         return;
 210:tmk_core/common/action.c ****     }
 211:tmk_core/common/action.c **** 
 212:tmk_core/common/action.c ****     process_record_handler(record);
 213:tmk_core/common/action.c ****     post_process_record_quantum(record);
 214:tmk_core/common/action.c **** }
 215:tmk_core/common/action.c **** 
 216:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 217:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 218:tmk_core/common/action.c ****     dprint("ACTION: ");
 219:tmk_core/common/action.c ****     debug_action(action);
 220:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 221:tmk_core/common/action.c ****     dprint(" layer_state: ");
 222:tmk_core/common/action.c ****     layer_debug();
 223:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 224:tmk_core/common/action.c ****     default_layer_debug();
 225:tmk_core/common/action.c **** #endif
 226:tmk_core/common/action.c ****     dprintln();
 227:tmk_core/common/action.c **** 
 228:tmk_core/common/action.c ****     process_action(record, action);
 229:tmk_core/common/action.c **** }
 230:tmk_core/common/action.c **** 
 231:tmk_core/common/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 232:tmk_core/common/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 233:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 234:tmk_core/common/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 235:tmk_core/common/action.c **** #    endif
 236:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 237:tmk_core/common/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 238:tmk_core/common/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 239:tmk_core/common/action.c ****     pointing_device_set_report(currentReport);
 240:tmk_core/common/action.c **** #    endif
 241:tmk_core/common/action.c **** }
 242:tmk_core/common/action.c **** #endif
 243:tmk_core/common/action.c **** 
 244:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 245:tmk_core/common/action.c ****  *
 246:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 247:tmk_core/common/action.c ****  */
 248:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 249:tmk_core/common/action.c ****     keyevent_t event = record->event;
 250:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 251:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 252:tmk_core/common/action.c **** #endif
 253:tmk_core/common/action.c **** 
 254:tmk_core/common/action.c ****     if (event.pressed) {
 255:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 256:tmk_core/common/action.c ****         clear_weak_mods();
 257:tmk_core/common/action.c ****     }
 258:tmk_core/common/action.c **** 
 259:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 260:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 261:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 262:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 263:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 264:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 265:tmk_core/common/action.c **** #    endif
 266:tmk_core/common/action.c ****     ) {
 267:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 268:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 269:tmk_core/common/action.c ****     }
 270:tmk_core/common/action.c **** #endif
 271:tmk_core/common/action.c **** 
 272:tmk_core/common/action.c ****     switch (action.kind.id) {
 273:tmk_core/common/action.c ****         /* Key and Mods */
 274:tmk_core/common/action.c ****         case ACT_LMODS:
 275:tmk_core/common/action.c ****         case ACT_RMODS: {
 276:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 277:tmk_core/common/action.c ****             if (event.pressed) {
 278:tmk_core/common/action.c ****                 if (mods) {
 279:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 280:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 281:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 282:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 283:tmk_core/common/action.c ****                         add_mods(mods);
 284:tmk_core/common/action.c ****                     } else {
 285:tmk_core/common/action.c ****                         add_weak_mods(mods);
 286:tmk_core/common/action.c ****                     }
 287:tmk_core/common/action.c ****                     send_keyboard_report();
 288:tmk_core/common/action.c ****                 }
 289:tmk_core/common/action.c ****                 register_code(action.key.code);
 290:tmk_core/common/action.c ****             } else {
 291:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 292:tmk_core/common/action.c ****                 if (mods) {
 293:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 294:tmk_core/common/action.c ****                         del_mods(mods);
 295:tmk_core/common/action.c ****                     } else {
 296:tmk_core/common/action.c ****                         del_weak_mods(mods);
 297:tmk_core/common/action.c ****                     }
 298:tmk_core/common/action.c ****                     send_keyboard_report();
 299:tmk_core/common/action.c ****                 }
 300:tmk_core/common/action.c ****             }
 301:tmk_core/common/action.c ****         } break;
 302:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 303:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 304:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 305:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 306:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 307:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 308:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 309:tmk_core/common/action.c ****                     // Oneshot modifier
 310:tmk_core/common/action.c ****                     if (event.pressed) {
 311:tmk_core/common/action.c ****                         if (tap_count == 0) {
 312:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 313:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 314:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 315:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 316:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 317:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 318:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 319:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 320:tmk_core/common/action.c ****                             clear_oneshot_mods();
 321:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 322:tmk_core/common/action.c ****                             register_mods(mods);
 323:tmk_core/common/action.c **** #        endif
 324:tmk_core/common/action.c ****                         } else {
 325:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 326:tmk_core/common/action.c ****                         }
 327:tmk_core/common/action.c ****                     } else {
 328:tmk_core/common/action.c ****                         if (tap_count == 0) {
 329:tmk_core/common/action.c ****                             clear_oneshot_mods();
 330:tmk_core/common/action.c ****                             unregister_mods(mods);
 331:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 332:tmk_core/common/action.c ****                             // Retain Oneshot mods
 333:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 334:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 335:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 336:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 337:tmk_core/common/action.c ****                                 unregister_mods(mods);
 338:tmk_core/common/action.c ****                             }
 339:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 340:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 341:tmk_core/common/action.c **** #        endif
 342:tmk_core/common/action.c ****                         } else {
 343:tmk_core/common/action.c ****                             clear_oneshot_mods();
 344:tmk_core/common/action.c ****                             unregister_mods(mods);
 345:tmk_core/common/action.c ****                         }
 346:tmk_core/common/action.c ****                     }
 347:tmk_core/common/action.c ****                     break;
 348:tmk_core/common/action.c **** #    endif
 349:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 350:tmk_core/common/action.c ****                     if (event.pressed) {
 351:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 352:tmk_core/common/action.c ****                             register_mods(mods);
 353:tmk_core/common/action.c ****                         }
 354:tmk_core/common/action.c ****                     } else {
 355:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 356:tmk_core/common/action.c ****                             unregister_mods(mods);
 357:tmk_core/common/action.c ****                         }
 358:tmk_core/common/action.c ****                     }
 359:tmk_core/common/action.c ****                     break;
 360:tmk_core/common/action.c ****                 default:
 361:tmk_core/common/action.c ****                     if (event.pressed) {
 362:tmk_core/common/action.c ****                         if (tap_count > 0) {
 363:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 364:tmk_core/common/action.c ****                             if (
 365:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 366:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 367:tmk_core/common/action.c **** #        endif
 368:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 369:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 370:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 371:tmk_core/common/action.c ****                                 record->tap.count = 0;
 372:tmk_core/common/action.c ****                                 register_mods(mods);
 373:tmk_core/common/action.c ****                             } else
 374:tmk_core/common/action.c **** #    endif
 375:tmk_core/common/action.c ****                             {
 376:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 377:tmk_core/common/action.c ****                                 register_code(action.key.code);
 378:tmk_core/common/action.c ****                             }
 379:tmk_core/common/action.c ****                         } else {
 380:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 381:tmk_core/common/action.c ****                             register_mods(mods);
 382:tmk_core/common/action.c ****                         }
 383:tmk_core/common/action.c ****                     } else {
 384:tmk_core/common/action.c ****                         if (tap_count > 0) {
 385:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 386:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 387:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 388:tmk_core/common/action.c ****                             } else {
 389:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 390:tmk_core/common/action.c ****                             }
 391:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 392:tmk_core/common/action.c ****                         } else {
 393:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 394:tmk_core/common/action.c ****                             unregister_mods(mods);
 395:tmk_core/common/action.c ****                         }
 396:tmk_core/common/action.c ****                     }
 397:tmk_core/common/action.c ****                     break;
 398:tmk_core/common/action.c ****             }
 399:tmk_core/common/action.c ****         } break;
 400:tmk_core/common/action.c **** #endif
 401:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 402:tmk_core/common/action.c ****         /* other HID usage */
 403:tmk_core/common/action.c ****         case ACT_USAGE:
 404:tmk_core/common/action.c ****             switch (action.usage.page) {
 405:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 406:tmk_core/common/action.c ****                     if (event.pressed) {
 407:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 408:tmk_core/common/action.c ****                     } else {
 409:tmk_core/common/action.c ****                         host_system_send(0);
 410:tmk_core/common/action.c ****                     }
 411:tmk_core/common/action.c ****                     break;
 412:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 413:tmk_core/common/action.c ****                     if (event.pressed) {
 414:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 415:tmk_core/common/action.c ****                     } else {
 416:tmk_core/common/action.c ****                         host_consumer_send(0);
 417:tmk_core/common/action.c ****                     }
 418:tmk_core/common/action.c ****                     break;
 419:tmk_core/common/action.c ****             }
 420:tmk_core/common/action.c ****             break;
 421:tmk_core/common/action.c **** #endif
 422:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 423:tmk_core/common/action.c ****         /* Mouse key */
 424:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 425:tmk_core/common/action.c ****             if (event.pressed) {
 426:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 427:tmk_core/common/action.c ****                 switch (action.key.code) {
 428:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 429:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 430:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN1);
 431:tmk_core/common/action.c ****                         break;
 432:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 433:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN2);
 434:tmk_core/common/action.c ****                         break;
 435:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 436:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN3);
 437:tmk_core/common/action.c ****                         break;
 438:tmk_core/common/action.c **** #    endif
 439:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 440:tmk_core/common/action.c ****                     case KC_MS_BTN4:
 441:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN4);
 442:tmk_core/common/action.c ****                         break;
 443:tmk_core/common/action.c ****                     case KC_MS_BTN5:
 444:tmk_core/common/action.c ****                         register_button(true, MOUSE_BTN5);
 445:tmk_core/common/action.c ****                         break;
 446:tmk_core/common/action.c **** #    endif
 447:tmk_core/common/action.c ****                     default:
 448:tmk_core/common/action.c ****                         mousekey_send();
 449:tmk_core/common/action.c ****                         break;
 450:tmk_core/common/action.c ****                 }
 451:tmk_core/common/action.c ****             } else {
 452:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 453:tmk_core/common/action.c ****                 switch (action.key.code) {
 454:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 455:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 456:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN1);
 457:tmk_core/common/action.c ****                         break;
 458:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 459:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN2);
 460:tmk_core/common/action.c ****                         break;
 461:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 462:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN3);
 463:tmk_core/common/action.c ****                         break;
 464:tmk_core/common/action.c **** #    endif
 465:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 466:tmk_core/common/action.c ****                     case KC_MS_BTN4:
 467:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN4);
 468:tmk_core/common/action.c ****                         break;
 469:tmk_core/common/action.c ****                     case KC_MS_BTN5:
 470:tmk_core/common/action.c ****                         register_button(false, MOUSE_BTN5);
 471:tmk_core/common/action.c ****                         break;
 472:tmk_core/common/action.c **** #    endif
 473:tmk_core/common/action.c ****                     default:
 474:tmk_core/common/action.c ****                         mousekey_send();
 475:tmk_core/common/action.c ****                         break;
 476:tmk_core/common/action.c ****                 }
 477:tmk_core/common/action.c ****             }
 478:tmk_core/common/action.c ****             break;
 479:tmk_core/common/action.c **** #endif
 480:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 481:tmk_core/common/action.c ****         case ACT_LAYER:
 482:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 483:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 484:tmk_core/common/action.c ****                 if (!event.pressed) {
 485:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 486:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 487:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 488:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 489:tmk_core/common/action.c ****                         case OP_BIT_AND:
 490:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 491:tmk_core/common/action.c ****                             break;
 492:tmk_core/common/action.c ****                         case OP_BIT_OR:
 493:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 494:tmk_core/common/action.c ****                             break;
 495:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 496:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 497:tmk_core/common/action.c ****                             break;
 498:tmk_core/common/action.c ****                         case OP_BIT_SET:
 499:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 500:tmk_core/common/action.c ****                             break;
 501:tmk_core/common/action.c ****                     }
 502:tmk_core/common/action.c ****                 }
 503:tmk_core/common/action.c ****             } else {
 504:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 505:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 506:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 507:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 508:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 509:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 510:tmk_core/common/action.c ****                         case OP_BIT_AND:
 511:tmk_core/common/action.c ****                             layer_and(bits | mask);
 512:tmk_core/common/action.c ****                             break;
 513:tmk_core/common/action.c ****                         case OP_BIT_OR:
 514:tmk_core/common/action.c ****                             layer_or(bits | mask);
 515:tmk_core/common/action.c ****                             break;
 516:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 517:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 518:tmk_core/common/action.c ****                             break;
 519:tmk_core/common/action.c ****                         case OP_BIT_SET:
 520:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 521:tmk_core/common/action.c ****                             break;
 522:tmk_core/common/action.c ****                     }
 523:tmk_core/common/action.c ****                 }
 524:tmk_core/common/action.c ****             }
 525:tmk_core/common/action.c ****             break;
 526:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 527:tmk_core/common/action.c ****             if (event.pressed) {
 528:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 529:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 530:tmk_core/common/action.c ****             } else {
 531:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 532:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 533:tmk_core/common/action.c ****             }
 534:tmk_core/common/action.c ****             break;
 535:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 536:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 537:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 538:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 539:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 540:tmk_core/common/action.c ****                     /* tap toggle */
 541:tmk_core/common/action.c ****                     if (event.pressed) {
 542:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 543:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 544:tmk_core/common/action.c ****                         }
 545:tmk_core/common/action.c ****                     } else {
 546:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 547:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 548:tmk_core/common/action.c ****                         }
 549:tmk_core/common/action.c ****                     }
 550:tmk_core/common/action.c ****                     break;
 551:tmk_core/common/action.c ****                 case OP_ON_OFF:
 552:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 553:tmk_core/common/action.c ****                     break;
 554:tmk_core/common/action.c ****                 case OP_OFF_ON:
 555:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 556:tmk_core/common/action.c ****                     break;
 557:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 558:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 559:tmk_core/common/action.c ****                     break;
 560:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 561:tmk_core/common/action.c ****                 case OP_ONESHOT:
 562:tmk_core/common/action.c ****                     // Oneshot modifier
 563:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 564:tmk_core/common/action.c ****                     do_release_oneshot = false;
 565:tmk_core/common/action.c ****                     if (event.pressed) {
 566:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 567:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 568:tmk_core/common/action.c ****                             reset_oneshot_layer();
 569:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 570:tmk_core/common/action.c ****                             break;
 571:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 572:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 573:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 574:tmk_core/common/action.c ****                         }
 575:tmk_core/common/action.c ****                     } else {
 576:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 577:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 578:tmk_core/common/action.c ****                             reset_oneshot_layer();
 579:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 580:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 581:tmk_core/common/action.c ****                         } else {
 582:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 583:tmk_core/common/action.c ****                         }
 584:tmk_core/common/action.c ****                     }
 585:tmk_core/common/action.c **** #            else
 586:tmk_core/common/action.c ****                     if (event.pressed) {
 587:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 588:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 589:tmk_core/common/action.c ****                     } else {
 590:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 591:tmk_core/common/action.c ****                         if (tap_count > 1) {
 592:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 593:tmk_core/common/action.c ****                         }
 594:tmk_core/common/action.c ****                     }
 595:tmk_core/common/action.c **** #            endif
 596:tmk_core/common/action.c ****                     break;
 597:tmk_core/common/action.c **** #        endif
 598:tmk_core/common/action.c ****                 default:
 599:tmk_core/common/action.c ****                     /* tap key */
 600:tmk_core/common/action.c ****                     if (event.pressed) {
 601:tmk_core/common/action.c ****                         if (tap_count > 0) {
 602:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 603:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 604:tmk_core/common/action.c ****                         } else {
 605:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 606:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 607:tmk_core/common/action.c ****                         }
 608:tmk_core/common/action.c ****                     } else {
 609:tmk_core/common/action.c ****                         if (tap_count > 0) {
 610:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 611:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 612:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 613:tmk_core/common/action.c ****                             } else {
 614:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 615:tmk_core/common/action.c ****                             }
 616:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 617:tmk_core/common/action.c ****                         } else {
 618:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 619:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 620:tmk_core/common/action.c ****                         }
 621:tmk_core/common/action.c ****                     }
 622:tmk_core/common/action.c ****                     break;
 623:tmk_core/common/action.c ****             }
 624:tmk_core/common/action.c ****             break;
 625:tmk_core/common/action.c **** #    endif
 626:tmk_core/common/action.c **** #endif
 627:tmk_core/common/action.c ****             /* Extentions */
 628:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 629:tmk_core/common/action.c ****         case ACT_MACRO:
 630:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 631:tmk_core/common/action.c ****             break;
 632:tmk_core/common/action.c **** #endif
 633:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 634:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 635:tmk_core/common/action.c ****             switch (action.swap.code) {
 636:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 637:tmk_core/common/action.c ****                     if (event.pressed) {
 638:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 639:tmk_core/common/action.c ****                     }
 640:tmk_core/common/action.c ****                     break;
 641:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 642:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 643:tmk_core/common/action.c ****                     break;
 644:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 645:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 646:tmk_core/common/action.c ****                     break;
 647:tmk_core/common/action.c ****                 case OP_SH_ON:
 648:tmk_core/common/action.c ****                     if (!event.pressed) {
 649:tmk_core/common/action.c ****                         swap_hands = true;
 650:tmk_core/common/action.c ****                     }
 651:tmk_core/common/action.c ****                     break;
 652:tmk_core/common/action.c ****                 case OP_SH_OFF:
 653:tmk_core/common/action.c ****                     if (!event.pressed) {
 654:tmk_core/common/action.c ****                         swap_hands = false;
 655:tmk_core/common/action.c ****                     }
 656:tmk_core/common/action.c ****                     break;
 657:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 658:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 659:tmk_core/common/action.c ****                     if (event.pressed) {
 660:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 661:tmk_core/common/action.c ****                     } else {
 662:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 663:tmk_core/common/action.c ****                     }
 664:tmk_core/common/action.c ****                     break;
 665:tmk_core/common/action.c **** #    endif
 666:tmk_core/common/action.c **** 
 667:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 668:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 669:tmk_core/common/action.c ****                     /* tap toggle */
 670:tmk_core/common/action.c **** 
 671:tmk_core/common/action.c ****                     if (event.pressed) {
 672:tmk_core/common/action.c ****                         if (swap_held) {
 673:tmk_core/common/action.c ****                             swap_held = false;
 674:tmk_core/common/action.c ****                         } else {
 675:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 676:tmk_core/common/action.c ****                         }
 677:tmk_core/common/action.c ****                     } else {
 678:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 679:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 680:tmk_core/common/action.c ****                         }
 681:tmk_core/common/action.c ****                     }
 682:tmk_core/common/action.c ****                     break;
 683:tmk_core/common/action.c ****                 default:
 684:tmk_core/common/action.c ****                     /* tap key */
 685:tmk_core/common/action.c ****                     if (tap_count > 0) {
 686:tmk_core/common/action.c ****                         if (swap_held) {
 687:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 688:tmk_core/common/action.c ****                             swap_held  = false;
 689:tmk_core/common/action.c ****                         }
 690:tmk_core/common/action.c ****                         if (event.pressed) {
 691:tmk_core/common/action.c ****                             register_code(action.swap.code);
 692:tmk_core/common/action.c ****                         } else {
 693:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 694:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 695:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 696:tmk_core/common/action.c ****                         }
 697:tmk_core/common/action.c ****                     } else {
 698:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 699:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 700:tmk_core/common/action.c ****                             swap_held  = false;
 701:tmk_core/common/action.c ****                         }
 702:tmk_core/common/action.c ****                     }
 703:tmk_core/common/action.c **** #    endif
 704:tmk_core/common/action.c ****             }
 705:tmk_core/common/action.c **** #endif
 706:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 707:tmk_core/common/action.c ****         case ACT_FUNCTION:
 708:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 709:tmk_core/common/action.c ****             break;
 710:tmk_core/common/action.c **** #endif
 711:tmk_core/common/action.c ****         default:
 712:tmk_core/common/action.c ****             break;
 713:tmk_core/common/action.c ****     }
 714:tmk_core/common/action.c **** 
 715:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 716:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 717:tmk_core/common/action.c ****     switch (action.kind.id) {
 718:tmk_core/common/action.c ****         case ACT_LAYER:
 719:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 720:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 721:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 722:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 723:tmk_core/common/action.c **** #    endif
 724:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 725:tmk_core/common/action.c ****             break;
 726:tmk_core/common/action.c ****         default:
 727:tmk_core/common/action.c ****             break;
 728:tmk_core/common/action.c ****     }
 729:tmk_core/common/action.c **** #endif
 730:tmk_core/common/action.c **** 
 731:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 732:tmk_core/common/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 733:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 734:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 735:tmk_core/common/action.c ****     } else {
 736:tmk_core/common/action.c ****         if (event.pressed) {
 737:tmk_core/common/action.c ****             if (tap_count > 0) {
 738:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 739:tmk_core/common/action.c ****             }
 740:tmk_core/common/action.c ****         } else {
 741:tmk_core/common/action.c ****             if (tap_count > 0) {
 742:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 743:tmk_core/common/action.c ****             } else {
 744:tmk_core/common/action.c ****                 if (
 745:tmk_core/common/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 746:tmk_core/common/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 747:tmk_core/common/action.c **** #        endif
 748:tmk_core/common/action.c ****                     retro_tapping_counter == 2) {
 749:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 750:tmk_core/common/action.c ****                 }
 751:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 752:tmk_core/common/action.c ****             }
 753:tmk_core/common/action.c ****         }
 754:tmk_core/common/action.c ****     }
 755:tmk_core/common/action.c **** #    endif
 756:tmk_core/common/action.c **** #endif
 757:tmk_core/common/action.c **** 
 758:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 759:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 760:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 761:tmk_core/common/action.c ****         use_oneshot_swaphands();
 762:tmk_core/common/action.c ****     }
 763:tmk_core/common/action.c **** #    endif
 764:tmk_core/common/action.c **** #endif
 765:tmk_core/common/action.c **** 
 766:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 767:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 768:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 769:tmk_core/common/action.c ****      */
 770:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 771:tmk_core/common/action.c ****         record->event.pressed = false;
 772:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 773:tmk_core/common/action.c ****         process_record(record);
 774:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 775:tmk_core/common/action.c ****     }
 776:tmk_core/common/action.c **** #endif
 777:tmk_core/common/action.c **** }
 778:tmk_core/common/action.c **** 
 779:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 780:tmk_core/common/action.c ****  *
 781:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 782:tmk_core/common/action.c ****  */
 783:tmk_core/common/action.c **** void register_code(uint8_t code) {
 163               		.loc 1 783 34 is_stmt 1 view -0
 164               		.cfi_startproc
 165               		.loc 1 783 34 is_stmt 0 view .LVU23
 166 0000 CF93      		push r28
 167               	.LCFI4:
 168               		.cfi_def_cfa_offset 3
 169               		.cfi_offset 28, -2
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 172               	/* stack size = 1 */
 173               	.L__stack_usage = 1
 174 0002 C82F      		mov r28,r24
 784:tmk_core/common/action.c ****     if (code == KC_NO) {
 175               		.loc 1 784 5 is_stmt 1 view .LVU24
 176               		.loc 1 784 8 is_stmt 0 view .LVU25
 177 0004 8823      		tst r24
 178 0006 01F4      		brne .+2
 179 0008 00C0      		rjmp .L5
 785:tmk_core/common/action.c ****         return;
 786:tmk_core/common/action.c ****     }
 787:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 788:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 180               		.loc 1 788 10 is_stmt 1 view .LVU26
 181               		.loc 1 788 13 is_stmt 0 view .LVU27
 182 000a 8238      		cpi r24,lo8(-126)
 183 000c 01F4      		brne .L8
 789:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 790:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 791:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 184               		.loc 1 791 9 is_stmt 1 view .LVU28
 185               		.loc 1 791 13 is_stmt 0 view .LVU29
 186 000e 0E94 0000 		call host_keyboard_leds
 187               	.LVL11:
 188               		.loc 1 791 12 view .LVU30
 189 0012 81FD      		sbrc r24,1
 190 0014 00C0      		rjmp .L5
 792:tmk_core/common/action.c **** #    endif
 793:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 191               		.loc 1 793 9 is_stmt 1 view .LVU31
 192 0016 89E3      		ldi r24,lo8(57)
 193 0018 0E94 0000 		call add_key
 194               	.LVL12:
 794:tmk_core/common/action.c ****         send_keyboard_report();
 195               		.loc 1 794 9 view .LVU32
 196 001c 0E94 0000 		call send_keyboard_report
 197               	.LVL13:
 795:tmk_core/common/action.c ****         wait_ms(100);
 198               		.loc 1 795 9 view .LVU33
 199               	.LBB34:
 200               	.LBI34:
 201               		.file 2 "c:\\program files\\qmk_msys\\mingw64\\avr\\include\\util\\delay.h"
   1:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    All rights reserved.
   5:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
   6:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
   9:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  12:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****      distribution.
  16:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  17:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  21:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  33:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  35:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  38:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #  endif
  42:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  44:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #include <math.h>
  47:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  48:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** /** \file */
  49:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     \code
  51:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     \endcode
  55:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  56:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     used.
  60:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  61:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  70:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  79:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  83:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** */
  84:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  85:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #endif
  89:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  90:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     \def F_CPU
  95:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
  97:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 103:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****     integer value.
 107:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****  */
 108:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #endif
 110:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 111:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #endif
 114:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 115:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #  include <math.h>
 119:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #endif
 120:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 121:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** /**
 122:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 124:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 126:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 129:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 131:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 137:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 142:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 147:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    respectively.
 151:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 152:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    \note
 153:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 154:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 164:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****  */
 165:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** void
 166:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** _delay_ms(double __ms)
 202               		.loc 2 166 1 view .LVU34
 203               	.LBB35:
 167:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** {
 168:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	double __tmp ;
 204               		.loc 2 168 2 view .LVU35
 169:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 205               		.loc 2 172 2 view .LVU36
 173:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 206               		.loc 2 173 2 view .LVU37
 174:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 207               		.loc 2 174 2 view .LVU38
 175:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 176:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 179:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 182:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	#else
 183:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 		//round up by default
 184:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 208               		.loc 2 184 3 view .LVU39
 185:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 186:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 187:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 209               		.loc 2 187 2 view .LVU40
 210 0020 2FEF      		ldi r18,lo8(159999)
 211 0022 80E7      		ldi r24,hi8(159999)
 212 0024 92E0      		ldi r25,hlo8(159999)
 213 0026 2150      	1:	subi r18,1
 214 0028 8040      		sbci r24,0
 215 002a 9040      		sbci r25,0
 216 002c 01F4      		brne 1b
 217 002e 00C0      		rjmp .
 218 0030 0000      		nop
 219               	.LVL14:
 220               		.loc 2 187 2 is_stmt 0 view .LVU41
 221               	.LBE35:
 222               	.LBE34:
 796:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 223               		.loc 1 796 9 is_stmt 1 view .LVU42
 224 0032 89E3      		ldi r24,lo8(57)
 225               	.L19:
 797:tmk_core/common/action.c ****         send_keyboard_report();
 798:tmk_core/common/action.c ****     }
 799:tmk_core/common/action.c **** 
 800:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 801:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 802:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 803:tmk_core/common/action.c **** #    endif
 804:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 805:tmk_core/common/action.c ****         send_keyboard_report();
 806:tmk_core/common/action.c ****         wait_ms(100);
 807:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 226               		.loc 1 807 9 is_stmt 0 view .LVU43
 227 0034 0E94 0000 		call del_key
 228               	.LVL15:
 229               	.L20:
 808:tmk_core/common/action.c ****         send_keyboard_report();
 230               		.loc 1 808 9 is_stmt 1 view .LVU44
 231               	/* epilogue start */
 809:tmk_core/common/action.c ****     }
 810:tmk_core/common/action.c **** 
 811:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 812:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 813:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 814:tmk_core/common/action.c **** #    endif
 815:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 816:tmk_core/common/action.c ****         send_keyboard_report();
 817:tmk_core/common/action.c ****         wait_ms(100);
 818:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 819:tmk_core/common/action.c ****         send_keyboard_report();
 820:tmk_core/common/action.c ****     }
 821:tmk_core/common/action.c **** #endif
 822:tmk_core/common/action.c **** 
 823:tmk_core/common/action.c ****     else if
 824:tmk_core/common/action.c ****         IS_KEY(code) {
 825:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 826:tmk_core/common/action.c ****             if (command_proc(code)) return;
 827:tmk_core/common/action.c **** 
 828:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 829:tmk_core/common/action.c **** /* TODO: remove
 830:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 831:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 832:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 833:tmk_core/common/action.c **** 
 834:tmk_core/common/action.c ****             add_key(code);
 835:tmk_core/common/action.c ****             send_keyboard_report();
 836:tmk_core/common/action.c **** 
 837:tmk_core/common/action.c ****             set_mods(tmp_mods);
 838:tmk_core/common/action.c ****             send_keyboard_report();
 839:tmk_core/common/action.c ****             oneshot_cancel();
 840:tmk_core/common/action.c ****         } else
 841:tmk_core/common/action.c **** */
 842:tmk_core/common/action.c **** #endif
 843:tmk_core/common/action.c ****             {
 844:tmk_core/common/action.c ****                 // Force a new key press if the key is already pressed
 845:tmk_core/common/action.c ****                 // without this, keys with the same keycode, but different
 846:tmk_core/common/action.c ****                 // modifiers will be reported incorrectly, see issue #1708
 847:tmk_core/common/action.c ****                 if (is_key_pressed(keyboard_report, code)) {
 848:tmk_core/common/action.c ****                     del_key(code);
 849:tmk_core/common/action.c ****                     send_keyboard_report();
 850:tmk_core/common/action.c ****                 }
 851:tmk_core/common/action.c ****                 add_key(code);
 852:tmk_core/common/action.c ****                 send_keyboard_report();
 853:tmk_core/common/action.c ****             }
 854:tmk_core/common/action.c ****         }
 855:tmk_core/common/action.c ****     else if
 856:tmk_core/common/action.c ****         IS_MOD(code) {
 857:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 858:tmk_core/common/action.c ****             send_keyboard_report();
 859:tmk_core/common/action.c ****         }
 860:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 861:tmk_core/common/action.c ****     else if
 862:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 863:tmk_core/common/action.c ****     else if
 864:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 865:tmk_core/common/action.c **** #endif
 866:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 867:tmk_core/common/action.c ****     else if
 868:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 869:tmk_core/common/action.c ****             mousekey_on(code);
 870:tmk_core/common/action.c ****             mousekey_send();
 871:tmk_core/common/action.c ****         }
 872:tmk_core/common/action.c **** #endif
 873:tmk_core/common/action.c **** }
 232               		.loc 1 873 1 is_stmt 0 view .LVU45
 233 0038 CF91      		pop r28
 808:tmk_core/common/action.c ****         send_keyboard_report();
 234               		.loc 1 808 9 view .LVU46
 235 003a 0C94 0000 		jmp send_keyboard_report
 236               	.LVL16:
 237               	.L8:
 800:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 238               		.loc 1 800 10 is_stmt 1 view .LVU47
 800:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 239               		.loc 1 800 13 is_stmt 0 view .LVU48
 240 003e 8338      		cpi r24,lo8(-125)
 241 0040 01F4      		brne .L10
 802:tmk_core/common/action.c **** #    endif
 242               		.loc 1 802 9 is_stmt 1 view .LVU49
 802:tmk_core/common/action.c **** #    endif
 243               		.loc 1 802 13 is_stmt 0 view .LVU50
 244 0042 0E94 0000 		call host_keyboard_leds
 245               	.LVL17:
 802:tmk_core/common/action.c **** #    endif
 246               		.loc 1 802 12 view .LVU51
 247 0046 80FD      		sbrc r24,0
 248 0048 00C0      		rjmp .L5
 804:tmk_core/common/action.c ****         send_keyboard_report();
 249               		.loc 1 804 9 is_stmt 1 view .LVU52
 250 004a 83E5      		ldi r24,lo8(83)
 251 004c 0E94 0000 		call add_key
 252               	.LVL18:
 805:tmk_core/common/action.c ****         wait_ms(100);
 253               		.loc 1 805 9 view .LVU53
 254 0050 0E94 0000 		call send_keyboard_report
 255               	.LVL19:
 806:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 256               		.loc 1 806 9 view .LVU54
 257               	.LBB36:
 258               	.LBI36:
 166:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** {
 259               		.loc 2 166 1 view .LVU55
 260               	.LBB37:
 168:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 261               		.loc 2 168 2 view .LVU56
 172:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 262               		.loc 2 172 2 view .LVU57
 173:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 263               		.loc 2 173 2 view .LVU58
 174:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 264               		.loc 2 174 2 view .LVU59
 184:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 265               		.loc 2 184 3 view .LVU60
 266               		.loc 2 187 2 view .LVU61
 267 0054 2FEF      		ldi r18,lo8(159999)
 268 0056 80E7      		ldi r24,hi8(159999)
 269 0058 92E0      		ldi r25,hlo8(159999)
 270 005a 2150      	1:	subi r18,1
 271 005c 8040      		sbci r24,0
 272 005e 9040      		sbci r25,0
 273 0060 01F4      		brne 1b
 274 0062 00C0      		rjmp .
 275 0064 0000      		nop
 276               	.LVL20:
 277               		.loc 2 187 2 is_stmt 0 view .LVU62
 278               	.LBE37:
 279               	.LBE36:
 807:tmk_core/common/action.c ****         send_keyboard_report();
 280               		.loc 1 807 9 is_stmt 1 view .LVU63
 281 0066 83E5      		ldi r24,lo8(83)
 282 0068 00C0      		rjmp .L19
 283               	.LVL21:
 284               	.L10:
 811:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 285               		.loc 1 811 10 view .LVU64
 811:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 286               		.loc 1 811 13 is_stmt 0 view .LVU65
 287 006a 8438      		cpi r24,lo8(-124)
 288 006c 01F4      		brne .L11
 813:tmk_core/common/action.c **** #    endif
 289               		.loc 1 813 9 is_stmt 1 view .LVU66
 813:tmk_core/common/action.c **** #    endif
 290               		.loc 1 813 13 is_stmt 0 view .LVU67
 291 006e 0E94 0000 		call host_keyboard_leds
 292               	.LVL22:
 813:tmk_core/common/action.c **** #    endif
 293               		.loc 1 813 12 view .LVU68
 294 0072 82FD      		sbrc r24,2
 295 0074 00C0      		rjmp .L5
 815:tmk_core/common/action.c ****         send_keyboard_report();
 296               		.loc 1 815 9 is_stmt 1 view .LVU69
 297 0076 87E4      		ldi r24,lo8(71)
 298 0078 0E94 0000 		call add_key
 299               	.LVL23:
 816:tmk_core/common/action.c ****         wait_ms(100);
 300               		.loc 1 816 9 view .LVU70
 301 007c 0E94 0000 		call send_keyboard_report
 302               	.LVL24:
 817:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 303               		.loc 1 817 9 view .LVU71
 304               	.LBB38:
 305               	.LBI38:
 166:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** {
 306               		.loc 2 166 1 view .LVU72
 307               	.LBB39:
 168:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 308               		.loc 2 168 2 view .LVU73
 172:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 309               		.loc 2 172 2 view .LVU74
 173:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 310               		.loc 2 173 2 view .LVU75
 174:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 311               		.loc 2 174 2 view .LVU76
 184:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 312               		.loc 2 184 3 view .LVU77
 313               		.loc 2 187 2 view .LVU78
 314 0080 2FEF      		ldi r18,lo8(159999)
 315 0082 80E7      		ldi r24,hi8(159999)
 316 0084 92E0      		ldi r25,hlo8(159999)
 317 0086 2150      	1:	subi r18,1
 318 0088 8040      		sbci r24,0
 319 008a 9040      		sbci r25,0
 320 008c 01F4      		brne 1b
 321 008e 00C0      		rjmp .
 322 0090 0000      		nop
 323               	.LVL25:
 324               		.loc 2 187 2 is_stmt 0 view .LVU79
 325               	.LBE39:
 326               	.LBE38:
 818:tmk_core/common/action.c ****         send_keyboard_report();
 327               		.loc 1 818 9 is_stmt 1 view .LVU80
 328 0092 87E4      		ldi r24,lo8(71)
 329 0094 00C0      		rjmp .L19
 330               	.LVL26:
 331               	.L11:
 823:tmk_core/common/action.c ****         IS_KEY(code) {
 332               		.loc 1 823 10 view .LVU81
 824:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 333               		.loc 1 824 9 is_stmt 0 view .LVU82
 334 0096 8CEF      		ldi r24,lo8(-4)
 335               	.LVL27:
 824:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 336               		.loc 1 824 9 view .LVU83
 337 0098 8C0F      		add r24,r28
 338 009a 813A      		cpi r24,lo8(-95)
 339 009c 00F4      		brsh .L12
 826:tmk_core/common/action.c **** 
 340               		.loc 1 826 13 is_stmt 1 view .LVU84
 847:tmk_core/common/action.c ****                     del_key(code);
 341               		.loc 1 847 17 view .LVU85
 847:tmk_core/common/action.c ****                     del_key(code);
 342               		.loc 1 847 21 is_stmt 0 view .LVU86
 343 009e 6C2F      		mov r22,r28
 344 00a0 8091 0000 		lds r24,keyboard_report
 345 00a4 9091 0000 		lds r25,keyboard_report+1
 346 00a8 0E94 0000 		call is_key_pressed
 347               	.LVL28:
 847:tmk_core/common/action.c ****                     del_key(code);
 348               		.loc 1 847 20 view .LVU87
 349 00ac 8823      		tst r24
 350 00ae 01F0      		breq .L13
 848:tmk_core/common/action.c ****                     send_keyboard_report();
 351               		.loc 1 848 21 is_stmt 1 view .LVU88
 352 00b0 8C2F      		mov r24,r28
 353 00b2 0E94 0000 		call del_key
 354               	.LVL29:
 849:tmk_core/common/action.c ****                 }
 355               		.loc 1 849 21 view .LVU89
 356 00b6 0E94 0000 		call send_keyboard_report
 357               	.LVL30:
 358               	.L13:
 851:tmk_core/common/action.c ****                 send_keyboard_report();
 359               		.loc 1 851 17 view .LVU90
 360 00ba 8C2F      		mov r24,r28
 361 00bc 0E94 0000 		call add_key
 362               	.LVL31:
 852:tmk_core/common/action.c ****             }
 363               		.loc 1 852 17 view .LVU91
 364 00c0 00C0      		rjmp .L20
 365               	.L12:
 855:tmk_core/common/action.c ****         IS_MOD(code) {
 366               		.loc 1 855 10 view .LVU92
 856:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 367               		.loc 1 856 9 is_stmt 0 view .LVU93
 368 00c2 80E2      		ldi r24,lo8(32)
 369 00c4 8C0F      		add r24,r28
 370 00c6 8830      		cpi r24,lo8(8)
 371 00c8 00F4      		brsh .L14
 857:tmk_core/common/action.c ****             send_keyboard_report();
 372               		.loc 1 857 13 is_stmt 1 view .LVU94
 857:tmk_core/common/action.c ****             send_keyboard_report();
 373               		.loc 1 857 22 is_stmt 0 view .LVU95
 374 00ca C770      		andi r28,lo8(7)
 375               	.LVL32:
 857:tmk_core/common/action.c ****             send_keyboard_report();
 376               		.loc 1 857 13 view .LVU96
 377 00cc 81E0      		ldi r24,lo8(1)
 378 00ce 00C0      		rjmp 2f
 379               		1:
 380 00d0 880F      		lsl r24
 381               		2:
 382 00d2 CA95      		dec r28
 383 00d4 02F4      		brpl 1b
 384 00d6 0E94 0000 		call add_mods
 385               	.LVL33:
 858:tmk_core/common/action.c ****         }
 386               		.loc 1 858 13 is_stmt 1 view .LVU97
 387 00da 00C0      		rjmp .L20
 388               	.LVL34:
 389               	.L14:
 861:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 390               		.loc 1 861 10 view .LVU98
 862:tmk_core/common/action.c ****     else if
 391               		.loc 1 862 9 is_stmt 0 view .LVU99
 392 00dc EBE5      		ldi r30,lo8(91)
 393 00de EC0F      		add r30,r28
 394 00e0 E330      		cpi r30,lo8(3)
 395 00e2 00F4      		brsh .L15
 862:tmk_core/common/action.c ****     else if
 396               		.loc 1 862 27 is_stmt 1 view .LVU100
 397               	.LVL35:
 398               	.LBB40:
 399               	.LBI40:
 400               		.file 3 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK
  34:tmk_core/common/report.h **** };
  35:tmk_core/common/report.h **** 
  36:tmk_core/common/report.h **** /* Mouse buttons */
  37:tmk_core/common/report.h **** enum mouse_buttons {
  38:tmk_core/common/report.h ****     MOUSE_BTN1 = (1 << 0),
  39:tmk_core/common/report.h ****     MOUSE_BTN2 = (1 << 1),
  40:tmk_core/common/report.h ****     MOUSE_BTN3 = (1 << 2),
  41:tmk_core/common/report.h ****     MOUSE_BTN4 = (1 << 3),
  42:tmk_core/common/report.h ****     MOUSE_BTN5 = (1 << 4)
  43:tmk_core/common/report.h **** };
  44:tmk_core/common/report.h **** 
  45:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  46:tmk_core/common/report.h ****  *
  47:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  48:tmk_core/common/report.h ****  */
  49:tmk_core/common/report.h **** enum consumer_usages {
  50:tmk_core/common/report.h ****     // 15.5 Display Controls
  51:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  52:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  53:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  54:tmk_core/common/report.h ****     // 15.7 Transport Controls
  55:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  56:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  57:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  58:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  59:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  60:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  61:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  62:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  63:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  64:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  65:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  66:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  67:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  68:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  69:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  70:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  71:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  72:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  73:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  74:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  75:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  76:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  77:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  78:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  79:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  80:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
  81:tmk_core/common/report.h ****     AC_HOME                = 0x223,
  82:tmk_core/common/report.h ****     AC_BACK                = 0x224,
  83:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
  84:tmk_core/common/report.h ****     AC_STOP                = 0x226,
  85:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
  86:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
  87:tmk_core/common/report.h **** };
  88:tmk_core/common/report.h **** 
  89:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
  90:tmk_core/common/report.h ****  *
  91:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
  92:tmk_core/common/report.h ****  */
  93:tmk_core/common/report.h **** enum desktop_usages {
  94:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
  95:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN = 0x81,
  96:tmk_core/common/report.h ****     SYSTEM_SLEEP      = 0x82,
  97:tmk_core/common/report.h ****     SYSTEM_WAKE_UP    = 0x83
  98:tmk_core/common/report.h **** };
  99:tmk_core/common/report.h **** 
 100:tmk_core/common/report.h **** // clang-format on
 101:tmk_core/common/report.h **** 
 102:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 103:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 104:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 105:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 106:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 107:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 108:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 109:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 110:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 111:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 112:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 113:tmk_core/common/report.h **** #    else
 114:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 115:tmk_core/common/report.h **** #    endif
 116:tmk_core/common/report.h **** #endif
 117:tmk_core/common/report.h **** 
 118:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 119:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 120:tmk_core/common/report.h **** #else
 121:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 122:tmk_core/common/report.h **** #endif
 123:tmk_core/common/report.h **** 
 124:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 125:tmk_core/common/report.h **** 
 126:tmk_core/common/report.h **** #ifdef __cplusplus
 127:tmk_core/common/report.h **** extern "C" {
 128:tmk_core/common/report.h **** #endif
 129:tmk_core/common/report.h **** 
 130:tmk_core/common/report.h **** /*
 131:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 132:tmk_core/common/report.h ****  *
 133:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 134:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 135:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 136:tmk_core/common/report.h ****  *
 137:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 138:tmk_core/common/report.h ****  *
 139:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 140:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 141:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 142:tmk_core/common/report.h ****  *
 143:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 144:tmk_core/common/report.h ****  *
 145:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 146:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 147:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 148:tmk_core/common/report.h ****  *
 149:tmk_core/common/report.h ****  */
 150:tmk_core/common/report.h **** typedef union {
 151:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 152:tmk_core/common/report.h ****     struct {
 153:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 154:tmk_core/common/report.h ****         uint8_t report_id;
 155:tmk_core/common/report.h **** #endif
 156:tmk_core/common/report.h ****         uint8_t mods;
 157:tmk_core/common/report.h ****         uint8_t reserved;
 158:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 159:tmk_core/common/report.h ****     };
 160:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 161:tmk_core/common/report.h ****     struct nkro_report {
 162:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 163:tmk_core/common/report.h ****         uint8_t report_id;
 164:tmk_core/common/report.h **** #    endif
 165:tmk_core/common/report.h ****         uint8_t mods;
 166:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 167:tmk_core/common/report.h ****     } nkro;
 168:tmk_core/common/report.h **** #endif
 169:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 170:tmk_core/common/report.h **** 
 171:tmk_core/common/report.h **** typedef struct {
 172:tmk_core/common/report.h ****     uint8_t  report_id;
 173:tmk_core/common/report.h ****     uint16_t usage;
 174:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 175:tmk_core/common/report.h **** 
 176:tmk_core/common/report.h **** typedef struct {
 177:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 178:tmk_core/common/report.h ****     uint8_t report_id;
 179:tmk_core/common/report.h **** #endif
 180:tmk_core/common/report.h ****     uint8_t buttons;
 181:tmk_core/common/report.h ****     int8_t  x;
 182:tmk_core/common/report.h ****     int8_t  y;
 183:tmk_core/common/report.h ****     int8_t  v;
 184:tmk_core/common/report.h ****     int8_t  h;
 185:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 186:tmk_core/common/report.h **** 
 187:tmk_core/common/report.h **** typedef struct {
 188:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 189:tmk_core/common/report.h **** #    if JOYSTICK_AXES_RESOLUTION > 8
 190:tmk_core/common/report.h ****     int16_t axes[JOYSTICK_AXES_COUNT];
 191:tmk_core/common/report.h **** #    else
 192:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 193:tmk_core/common/report.h **** #    endif
 194:tmk_core/common/report.h **** #endif
 195:tmk_core/common/report.h **** 
 196:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 197:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 198:tmk_core/common/report.h **** #endif
 199:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 200:tmk_core/common/report.h **** 
 201:tmk_core/common/report.h **** /* keycode to system usage */
 202:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 401               		.loc 3 202 24 view .LVU101
 402               	.LBE40:
 203:tmk_core/common/report.h ****     switch (key) {
 403               		.loc 3 203 5 view .LVU102
 862:tmk_core/common/action.c ****     else if
 404               		.loc 1 862 27 is_stmt 0 view .LVU103
 405 00e4 F0E0      		ldi r31,0
 406 00e6 E050      		subi r30,lo8(-(CSWTCH.10))
 407 00e8 F040      		sbci r31,hi8(-(CSWTCH.10))
 408 00ea 8081      		ld r24,Z
 409 00ec 90E0      		ldi r25,0
 410               	/* epilogue start */
 411               		.loc 1 873 1 view .LVU104
 412 00ee CF91      		pop r28
 413               	.LVL36:
 862:tmk_core/common/action.c ****     else if
 414               		.loc 1 862 27 view .LVU105
 415 00f0 0C94 0000 		jmp host_system_send
 416               	.LVL37:
 417               	.L15:
 863:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 418               		.loc 1 863 10 is_stmt 1 view .LVU106
 864:tmk_core/common/action.c **** #endif
 419               		.loc 1 864 9 is_stmt 0 view .LVU107
 420 00f4 C85A      		subi r28,lo8(-(88))
 421               	.LVL38:
 864:tmk_core/common/action.c **** #endif
 422               		.loc 1 864 9 view .LVU108
 423 00f6 C731      		cpi r28,lo8(23)
 424 00f8 00F4      		brsh .L5
 864:tmk_core/common/action.c **** #endif
 425               		.loc 1 864 29 is_stmt 1 view .LVU109
 426               	.LVL39:
 427               	.LBB41:
 428               	.LBI41:
 204:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 205:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 206:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 207:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 208:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 209:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 210:tmk_core/common/report.h ****         default:
 211:tmk_core/common/report.h ****             return 0;
 212:tmk_core/common/report.h ****     }
 213:tmk_core/common/report.h **** }
 214:tmk_core/common/report.h **** 
 215:tmk_core/common/report.h **** /* keycode to consumer usage */
 216:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 429               		.loc 3 216 24 view .LVU110
 430               	.LBE41:
 217:tmk_core/common/report.h ****     switch (key) {
 431               		.loc 3 217 5 view .LVU111
 864:tmk_core/common/action.c **** #endif
 432               		.loc 1 864 29 is_stmt 0 view .LVU112
 433 00fa EC2F      		mov r30,r28
 434 00fc F0E0      		ldi r31,0
 435 00fe EE0F      		lsl r30
 436 0100 FF1F      		rol r31
 437 0102 E050      		subi r30,lo8(-(CSWTCH.11))
 438 0104 F040      		sbci r31,hi8(-(CSWTCH.11))
 439 0106 8081      		ld r24,Z
 440 0108 9181      		ldd r25,Z+1
 441               	/* epilogue start */
 442               		.loc 1 873 1 view .LVU113
 443 010a CF91      		pop r28
 444               	.LVL40:
 864:tmk_core/common/action.c **** #endif
 445               		.loc 1 864 29 view .LVU114
 446 010c 0C94 0000 		jmp host_consumer_send
 447               	.LVL41:
 448               	.L5:
 449               	/* epilogue start */
 450               		.loc 1 873 1 view .LVU115
 451 0110 CF91      		pop r28
 452 0112 0895      		ret
 453               		.cfi_endproc
 454               	.LFE116:
 456               		.section	.text.unregister_code,"ax",@progbits
 457               	.global	unregister_code
 459               	unregister_code:
 460               	.LVL42:
 461               	.LFB117:
 874:tmk_core/common/action.c **** 
 875:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 876:tmk_core/common/action.c ****  *
 877:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 878:tmk_core/common/action.c ****  */
 879:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 462               		.loc 1 879 36 is_stmt 1 view -0
 463               		.cfi_startproc
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 880:tmk_core/common/action.c ****     if (code == KC_NO) {
 468               		.loc 1 880 5 view .LVU117
 469               		.loc 1 880 8 is_stmt 0 view .LVU118
 470 0000 8823      		tst r24
 471 0002 01F4      		brne .+2
 472 0004 00C0      		rjmp .L21
 881:tmk_core/common/action.c ****         return;
 882:tmk_core/common/action.c ****     }
 883:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 884:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 473               		.loc 1 884 10 is_stmt 1 view .LVU119
 474               		.loc 1 884 13 is_stmt 0 view .LVU120
 475 0006 8238      		cpi r24,lo8(-126)
 476 0008 01F4      		brne .L24
 885:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 886:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 887:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 477               		.loc 1 887 9 is_stmt 1 view .LVU121
 478               		.loc 1 887 15 is_stmt 0 view .LVU122
 479 000a 0E94 0000 		call host_keyboard_leds
 480               	.LVL43:
 481               		.loc 1 887 12 view .LVU123
 482 000e 81FF      		sbrs r24,1
 483 0010 00C0      		rjmp .L21
 888:tmk_core/common/action.c **** #    endif
 889:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 484               		.loc 1 889 9 is_stmt 1 view .LVU124
 485 0012 89E3      		ldi r24,lo8(57)
 486 0014 0E94 0000 		call add_key
 487               	.LVL44:
 890:tmk_core/common/action.c ****         send_keyboard_report();
 488               		.loc 1 890 9 view .LVU125
 489 0018 0E94 0000 		call send_keyboard_report
 490               	.LVL45:
 891:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 491               		.loc 1 891 9 view .LVU126
 492 001c 89E3      		ldi r24,lo8(57)
 493               	.L40:
 892:tmk_core/common/action.c ****         send_keyboard_report();
 893:tmk_core/common/action.c ****     }
 894:tmk_core/common/action.c **** 
 895:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 896:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 897:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 898:tmk_core/common/action.c **** #    endif
 899:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 900:tmk_core/common/action.c ****         send_keyboard_report();
 901:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 494               		.loc 1 901 9 is_stmt 0 view .LVU127
 495 001e 0E94 0000 		call del_key
 496               	.LVL46:
 497               	.L41:
 902:tmk_core/common/action.c ****         send_keyboard_report();
 498               		.loc 1 902 9 is_stmt 1 view .LVU128
 499 0022 0C94 0000 		jmp send_keyboard_report
 500               	.LVL47:
 501               	.L24:
 895:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 502               		.loc 1 895 10 view .LVU129
 895:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 503               		.loc 1 895 13 is_stmt 0 view .LVU130
 504 0026 8338      		cpi r24,lo8(-125)
 505 0028 01F4      		brne .L26
 897:tmk_core/common/action.c **** #    endif
 506               		.loc 1 897 9 is_stmt 1 view .LVU131
 897:tmk_core/common/action.c **** #    endif
 507               		.loc 1 897 15 is_stmt 0 view .LVU132
 508 002a 0E94 0000 		call host_keyboard_leds
 509               	.LVL48:
 897:tmk_core/common/action.c **** #    endif
 510               		.loc 1 897 12 view .LVU133
 511 002e 80FF      		sbrs r24,0
 512 0030 00C0      		rjmp .L21
 899:tmk_core/common/action.c ****         send_keyboard_report();
 513               		.loc 1 899 9 is_stmt 1 view .LVU134
 514 0032 83E5      		ldi r24,lo8(83)
 515 0034 0E94 0000 		call add_key
 516               	.LVL49:
 900:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 517               		.loc 1 900 9 view .LVU135
 518 0038 0E94 0000 		call send_keyboard_report
 519               	.LVL50:
 901:tmk_core/common/action.c ****         send_keyboard_report();
 520               		.loc 1 901 9 view .LVU136
 521 003c 83E5      		ldi r24,lo8(83)
 522 003e 00C0      		rjmp .L40
 523               	.LVL51:
 524               	.L26:
 903:tmk_core/common/action.c ****     }
 904:tmk_core/common/action.c **** 
 905:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 525               		.loc 1 905 10 view .LVU137
 526               		.loc 1 905 13 is_stmt 0 view .LVU138
 527 0040 8438      		cpi r24,lo8(-124)
 528 0042 01F4      		brne .L27
 906:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 907:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 529               		.loc 1 907 9 is_stmt 1 view .LVU139
 530               		.loc 1 907 15 is_stmt 0 view .LVU140
 531 0044 0E94 0000 		call host_keyboard_leds
 532               	.LVL52:
 533               		.loc 1 907 12 view .LVU141
 534 0048 82FF      		sbrs r24,2
 535 004a 00C0      		rjmp .L21
 908:tmk_core/common/action.c **** #    endif
 909:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 536               		.loc 1 909 9 is_stmt 1 view .LVU142
 537 004c 87E4      		ldi r24,lo8(71)
 538 004e 0E94 0000 		call add_key
 539               	.LVL53:
 910:tmk_core/common/action.c ****         send_keyboard_report();
 540               		.loc 1 910 9 view .LVU143
 541 0052 0E94 0000 		call send_keyboard_report
 542               	.LVL54:
 911:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 543               		.loc 1 911 9 view .LVU144
 544 0056 87E4      		ldi r24,lo8(71)
 545 0058 00C0      		rjmp .L40
 546               	.LVL55:
 547               	.L27:
 912:tmk_core/common/action.c ****         send_keyboard_report();
 913:tmk_core/common/action.c ****     }
 914:tmk_core/common/action.c **** #endif
 915:tmk_core/common/action.c **** 
 916:tmk_core/common/action.c ****     else if
 548               		.loc 1 916 10 view .LVU145
 917:tmk_core/common/action.c ****         IS_KEY(code) {
 549               		.loc 1 917 9 is_stmt 0 view .LVU146
 550 005a 9CEF      		ldi r25,lo8(-4)
 551 005c 980F      		add r25,r24
 552 005e 913A      		cpi r25,lo8(-95)
 553 0060 00F0      		brlo .L40
 918:tmk_core/common/action.c ****             del_key(code);
 919:tmk_core/common/action.c ****             send_keyboard_report();
 920:tmk_core/common/action.c ****         }
 921:tmk_core/common/action.c ****     else if
 554               		.loc 1 921 10 is_stmt 1 view .LVU147
 922:tmk_core/common/action.c ****         IS_MOD(code) {
 555               		.loc 1 922 9 is_stmt 0 view .LVU148
 556 0062 90E2      		ldi r25,lo8(32)
 557 0064 980F      		add r25,r24
 558 0066 9830      		cpi r25,lo8(8)
 559 0068 00F4      		brsh .L29
 923:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 560               		.loc 1 923 13 is_stmt 1 view .LVU149
 561               		.loc 1 923 22 is_stmt 0 view .LVU150
 562 006a 8770      		andi r24,lo8(7)
 563               	.LVL56:
 564               		.loc 1 923 13 view .LVU151
 565 006c 91E0      		ldi r25,lo8(1)
 566 006e 00C0      		rjmp 2f
 567               		1:
 568 0070 990F      		lsl r25
 569               		2:
 570 0072 8A95      		dec r24
 571 0074 02F4      		brpl 1b
 572 0076 892F      		mov r24,r25
 573 0078 0E94 0000 		call del_mods
 574               	.LVL57:
 924:tmk_core/common/action.c ****             send_keyboard_report();
 575               		.loc 1 924 13 is_stmt 1 view .LVU152
 576 007c 00C0      		rjmp .L41
 577               	.LVL58:
 578               	.L29:
 925:tmk_core/common/action.c ****         }
 926:tmk_core/common/action.c ****     else if
 579               		.loc 1 926 10 view .LVU153
 927:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 580               		.loc 1 927 9 is_stmt 0 view .LVU154
 581 007e 9BE5      		ldi r25,lo8(91)
 582 0080 980F      		add r25,r24
 583 0082 9330      		cpi r25,lo8(3)
 584 0084 00F4      		brsh .L30
 585               		.loc 1 927 27 is_stmt 1 discriminator 1 view .LVU155
 586 0086 90E0      		ldi r25,0
 587 0088 80E0      		ldi r24,0
 588               	.LVL59:
 589               		.loc 1 927 27 is_stmt 0 discriminator 1 view .LVU156
 590 008a 0C94 0000 		jmp host_system_send
 591               	.LVL60:
 592               	.L30:
 928:tmk_core/common/action.c ****     else if
 593               		.loc 1 928 10 is_stmt 1 view .LVU157
 929:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 594               		.loc 1 929 9 is_stmt 0 view .LVU158
 595 008e 885A      		subi r24,lo8(-(88))
 596               	.LVL61:
 597               		.loc 1 929 9 view .LVU159
 598 0090 8731      		cpi r24,lo8(23)
 599 0092 00F4      		brsh .L21
 600               		.loc 1 929 29 is_stmt 1 discriminator 1 view .LVU160
 601 0094 90E0      		ldi r25,0
 602 0096 80E0      		ldi r24,0
 603               	.LVL62:
 604               		.loc 1 929 29 is_stmt 0 discriminator 1 view .LVU161
 605 0098 0C94 0000 		jmp host_consumer_send
 606               	.LVL63:
 607               	.L21:
 608               	/* epilogue start */
 930:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 931:tmk_core/common/action.c ****     else if
 932:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 933:tmk_core/common/action.c ****             mousekey_off(code);
 934:tmk_core/common/action.c ****             mousekey_send();
 935:tmk_core/common/action.c ****         }
 936:tmk_core/common/action.c **** #endif
 937:tmk_core/common/action.c **** }
 609               		.loc 1 937 1 view .LVU162
 610 009c 0895      		ret
 611               		.cfi_endproc
 612               	.LFE117:
 614               		.section	.text.tap_code,"ax",@progbits
 615               	.global	tap_code
 617               	tap_code:
 618               	.LVL64:
 619               	.LFB118:
 938:tmk_core/common/action.c **** 
 939:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 940:tmk_core/common/action.c ****  *
 941:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 942:tmk_core/common/action.c ****  */
 943:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 620               		.loc 1 943 29 is_stmt 1 view -0
 621               		.cfi_startproc
 622               		.loc 1 943 29 is_stmt 0 view .LVU164
 623 0000 CF93      		push r28
 624               	.LCFI5:
 625               		.cfi_def_cfa_offset 3
 626               		.cfi_offset 28, -2
 627               	/* prologue: function */
 628               	/* frame size = 0 */
 629               	/* stack size = 1 */
 630               	.L__stack_usage = 1
 631 0002 C82F      		mov r28,r24
 944:tmk_core/common/action.c ****     register_code(code);
 632               		.loc 1 944 5 is_stmt 1 view .LVU165
 633 0004 0E94 0000 		call register_code
 634               	.LVL65:
 945:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 635               		.loc 1 945 5 view .LVU166
 636               		.loc 1 945 8 is_stmt 0 view .LVU167
 637 0008 C933      		cpi r28,lo8(57)
 638 000a 01F4      		brne .L44
 946:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 639               		.loc 1 946 9 is_stmt 1 view .LVU168
 640               	.LVL66:
 641               	.LBB42:
 642               	.LBI42:
 166:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** {
 643               		.loc 2 166 1 view .LVU169
 644               	.LBB43:
 168:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 645               		.loc 2 168 2 view .LVU170
 172:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 646               		.loc 2 172 2 view .LVU171
 173:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 647               		.loc 2 173 2 view .LVU172
 174:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 648               		.loc 2 174 2 view .LVU173
 184:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 649               		.loc 2 184 3 view .LVU174
 650               		.loc 2 187 2 view .LVU175
 651 000c 2FEF      		ldi r18,lo8(127999)
 652 000e 83EF      		ldi r24,hi8(127999)
 653 0010 91E0      		ldi r25,hlo8(127999)
 654 0012 2150      	1:	subi r18,1
 655 0014 8040      		sbci r24,0
 656 0016 9040      		sbci r25,0
 657 0018 01F4      		brne 1b
 658 001a 00C0      		rjmp .
 659 001c 0000      		nop
 660               	.LVL67:
 661               	.L44:
 662               		.loc 2 187 2 is_stmt 0 view .LVU176
 663               	.LBE43:
 664               	.LBE42:
 947:tmk_core/common/action.c ****     } else {
 948:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 949:tmk_core/common/action.c ****     }
 950:tmk_core/common/action.c ****     unregister_code(code);
 665               		.loc 1 950 5 is_stmt 1 view .LVU177
 666 001e 8C2F      		mov r24,r28
 667               	/* epilogue start */
 951:tmk_core/common/action.c **** }
 668               		.loc 1 951 1 is_stmt 0 view .LVU178
 669 0020 CF91      		pop r28
 670               	.LVL68:
 950:tmk_core/common/action.c **** }
 671               		.loc 1 950 5 view .LVU179
 672 0022 0C94 0000 		jmp unregister_code
 673               	.LVL69:
 950:tmk_core/common/action.c **** }
 674               		.loc 1 950 5 view .LVU180
 675               		.cfi_endproc
 676               	.LFE118:
 678               		.section	.text.register_mods,"ax",@progbits
 679               	.global	register_mods
 681               	register_mods:
 682               	.LVL70:
 683               	.LFB119:
 952:tmk_core/common/action.c **** 
 953:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 954:tmk_core/common/action.c ****  *
 955:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 956:tmk_core/common/action.c ****  */
 957:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 684               		.loc 1 957 34 is_stmt 1 view -0
 685               		.cfi_startproc
 686               	/* prologue: function */
 687               	/* frame size = 0 */
 688               	/* stack size = 0 */
 689               	.L__stack_usage = 0
 958:tmk_core/common/action.c ****     if (mods) {
 690               		.loc 1 958 5 view .LVU182
 691               		.loc 1 958 8 is_stmt 0 view .LVU183
 692 0000 8823      		tst r24
 693 0002 01F0      		breq .L45
 959:tmk_core/common/action.c ****         add_mods(mods);
 694               		.loc 1 959 9 is_stmt 1 view .LVU184
 695 0004 0E94 0000 		call add_mods
 696               	.LVL71:
 960:tmk_core/common/action.c ****         send_keyboard_report();
 697               		.loc 1 960 9 view .LVU185
 698 0008 0C94 0000 		jmp send_keyboard_report
 699               	.LVL72:
 700               	.L45:
 701               	/* epilogue start */
 961:tmk_core/common/action.c ****     }
 962:tmk_core/common/action.c **** }
 702               		.loc 1 962 1 is_stmt 0 view .LVU186
 703 000c 0895      		ret
 704               		.cfi_endproc
 705               	.LFE119:
 707               		.section	.text.unregister_mods,"ax",@progbits
 708               	.global	unregister_mods
 710               	unregister_mods:
 711               	.LVL73:
 712               	.LFB120:
 963:tmk_core/common/action.c **** 
 964:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 965:tmk_core/common/action.c ****  *
 966:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 967:tmk_core/common/action.c ****  */
 968:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 713               		.loc 1 968 36 is_stmt 1 view -0
 714               		.cfi_startproc
 715               	/* prologue: function */
 716               	/* frame size = 0 */
 717               	/* stack size = 0 */
 718               	.L__stack_usage = 0
 969:tmk_core/common/action.c ****     if (mods) {
 719               		.loc 1 969 5 view .LVU188
 720               		.loc 1 969 8 is_stmt 0 view .LVU189
 721 0000 8823      		tst r24
 722 0002 01F0      		breq .L47
 970:tmk_core/common/action.c ****         del_mods(mods);
 723               		.loc 1 970 9 is_stmt 1 view .LVU190
 724 0004 0E94 0000 		call del_mods
 725               	.LVL74:
 971:tmk_core/common/action.c ****         send_keyboard_report();
 726               		.loc 1 971 9 view .LVU191
 727 0008 0C94 0000 		jmp send_keyboard_report
 728               	.LVL75:
 729               	.L47:
 730               	/* epilogue start */
 972:tmk_core/common/action.c ****     }
 973:tmk_core/common/action.c **** }
 731               		.loc 1 973 1 is_stmt 0 view .LVU192
 732 000c 0895      		ret
 733               		.cfi_endproc
 734               	.LFE120:
 736               		.section	.text.process_action,"ax",@progbits
 737               	.global	process_action
 739               	process_action:
 740               	.LVL76:
 741               	.LFB115:
 248:tmk_core/common/action.c ****     keyevent_t event = record->event;
 742               		.loc 1 248 59 is_stmt 1 view -0
 743               		.cfi_startproc
 248:tmk_core/common/action.c ****     keyevent_t event = record->event;
 744               		.loc 1 248 59 is_stmt 0 view .LVU194
 745 0000 BF92      		push r11
 746               	.LCFI6:
 747               		.cfi_def_cfa_offset 3
 748               		.cfi_offset 11, -2
 749 0002 CF92      		push r12
 750               	.LCFI7:
 751               		.cfi_def_cfa_offset 4
 752               		.cfi_offset 12, -3
 753 0004 DF92      		push r13
 754               	.LCFI8:
 755               		.cfi_def_cfa_offset 5
 756               		.cfi_offset 13, -4
 757 0006 EF92      		push r14
 758               	.LCFI9:
 759               		.cfi_def_cfa_offset 6
 760               		.cfi_offset 14, -5
 761 0008 FF92      		push r15
 762               	.LCFI10:
 763               		.cfi_def_cfa_offset 7
 764               		.cfi_offset 15, -6
 765 000a 0F93      		push r16
 766               	.LCFI11:
 767               		.cfi_def_cfa_offset 8
 768               		.cfi_offset 16, -7
 769 000c 1F93      		push r17
 770               	.LCFI12:
 771               		.cfi_def_cfa_offset 9
 772               		.cfi_offset 17, -8
 773 000e CF93      		push r28
 774               	.LCFI13:
 775               		.cfi_def_cfa_offset 10
 776               		.cfi_offset 28, -9
 777 0010 DF93      		push r29
 778               	.LCFI14:
 779               		.cfi_def_cfa_offset 11
 780               		.cfi_offset 29, -10
 781               	/* prologue: function */
 782               	/* frame size = 0 */
 783               	/* stack size = 9 */
 784               	.L__stack_usage = 9
 785 0012 6C01      		movw r12,r24
 786 0014 D62F      		mov r29,r22
 248:tmk_core/common/action.c ****     keyevent_t event = record->event;
 787               		.loc 1 248 59 view .LVU195
 788 0016 C72F      		mov r28,r23
 249:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 789               		.loc 1 249 5 is_stmt 1 view .LVU196
 790               	.LVL77:
 251:tmk_core/common/action.c **** #endif
 791               		.loc 1 251 5 view .LVU197
 251:tmk_core/common/action.c **** #endif
 792               		.loc 1 251 36 is_stmt 0 view .LVU198
 793 0018 FC01      		movw r30,r24
 794 001a 0581      		ldd r16,Z+5
 795 001c 0295      		swap r16
 796 001e 0F70      		andi r16,lo8(15)
 797               	.LVL78:
 254:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 798               		.loc 1 254 5 is_stmt 1 view .LVU199
 254:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 799               		.loc 1 254 14 is_stmt 0 view .LVU200
 800 0020 1281      		ldd r17,Z+2
 254:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 801               		.loc 1 254 8 view .LVU201
 802 0022 1111      		cpse r17,__zero_reg__
 256:tmk_core/common/action.c ****     }
 803               		.loc 1 256 9 is_stmt 1 view .LVU202
 804 0024 0E94 0000 		call clear_weak_mods
 805               	.LVL79:
 806               	.L50:
 260:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 807               		.loc 1 260 5 view .LVU203
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 808               		.loc 1 262 5 view .LVU204
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 809               		.loc 1 262 9 is_stmt 0 view .LVU205
 810 0028 0E94 0000 		call is_oneshot_layer_active
 811               	.LVL80:
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 812               		.loc 1 262 9 view .LVU206
 813 002c E82E      		mov r14,r24
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 814               		.loc 1 262 8 view .LVU207
 815 002e 8823      		tst r24
 816 0030 01F0      		breq .L51
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 817               		.loc 1 262 35 discriminator 1 view .LVU208
 818 0032 1123      		tst r17
 819 0034 01F0      		breq .L128
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 820               		.loc 1 262 71 discriminator 2 view .LVU209
 821 0036 8C2F      		mov r24,r28
 822 0038 807F      		andi r24,lo8(-16)
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 823               		.loc 1 262 52 discriminator 2 view .LVU210
 824 003a 8034      		cpi r24,lo8(64)
 825 003c 01F0      		breq .L52
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 826               		.loc 1 262 87 discriminator 3 view .LVU211
 827 003e 80E2      		ldi r24,lo8(32)
 828               	.LVL81:
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 829               		.loc 1 262 87 discriminator 3 view .LVU212
 830 0040 8D0F      		add r24,r29
 262:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 831               		.loc 1 262 84 discriminator 3 view .LVU213
 832 0042 8830      		cpi r24,lo8(8)
 833 0044 00F0      		brlo .L128
 834               	.L52:
 267:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 835               		.loc 1 267 9 is_stmt 1 view .LVU214
 836 0046 82E0      		ldi r24,lo8(2)
 837 0048 0E94 0000 		call clear_oneshot_layer_state
 838               	.LVL82:
 268:tmk_core/common/action.c ****     }
 839               		.loc 1 268 9 view .LVU215
 268:tmk_core/common/action.c ****     }
 840               		.loc 1 268 31 is_stmt 0 view .LVU216
 841 004c 0E94 0000 		call is_oneshot_layer_active
 842               	.LVL83:
 268:tmk_core/common/action.c ****     }
 843               		.loc 1 268 9 view .LVU217
 844 0050 91E0      		ldi r25,lo8(1)
 845 0052 E82E      		mov r14,r24
 846 0054 E926      		eor r14,r25
 847               	.LVL84:
 848               	.L51:
 272:tmk_core/common/action.c ****         /* Key and Mods */
 849               		.loc 1 272 5 is_stmt 1 view .LVU218
 272:tmk_core/common/action.c ****         /* Key and Mods */
 850               		.loc 1 272 24 is_stmt 0 view .LVU219
 851 0056 BC2E      		mov r11,r28
 852 0058 B294      		swap r11
 853 005a 9FE0      		ldi r25,lo8(15)
 854 005c B922      		and r11,r25
 272:tmk_core/common/action.c ****         /* Key and Mods */
 855               		.loc 1 272 5 view .LVU220
 856 005e EB2D      		mov r30,r11
 857 0060 F0E0      		ldi r31,0
 858 0062 E050      		subi r30,lo8(-(gs(.L55)))
 859 0064 F040      		sbci r31,hi8(-(gs(.L55)))
 860 0066 0C94 0000 		jmp __tablejump2__
 861               		.section	.jumptables.gcc.process_action,"a",@progbits
 862               		.p2align	1
 863               	.L55:
 864 0000 0000      		.word gs(.L62)
 865 0002 0000      		.word gs(.L62)
 866 0004 0000      		.word gs(.L61)
 867 0006 0000      		.word gs(.L61)
 868 0008 0000      		.word gs(.L60)
 869 000a 0000      		.word gs(.L53)
 870 000c 0000      		.word gs(.L53)
 871 000e 0000      		.word gs(.L53)
 872 0010 0000      		.word gs(.L59)
 873 0012 0000      		.word gs(.L58)
 874 0014 0000      		.word gs(.L57)
 875 0016 0000      		.word gs(.L57)
 876 0018 0000      		.word gs(.L56)
 877 001a 0000      		.word gs(.L53)
 878 001c 0000      		.word gs(.L53)
 879 001e 0000      		.word gs(.L54)
 880               		.section	.text.process_action
 881               	.LVL85:
 882               	.L128:
 260:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 883               		.loc 1 260 10 view .LVU221
 884 006a E12C      		mov r14,__zero_reg__
 885 006c 00C0      		rjmp .L51
 886               	.LVL86:
 887               	.L62:
 888               	.LBB44:
 276:tmk_core/common/action.c ****             if (event.pressed) {
 889               		.loc 1 276 13 is_stmt 1 view .LVU222
 890 006e 0C2F      		mov r16,r28
 891               	.LVL87:
 276:tmk_core/common/action.c ****             if (event.pressed) {
 892               		.loc 1 276 13 is_stmt 0 view .LVU223
 893 0070 0F70      		andi r16,lo8(15)
 276:tmk_core/common/action.c ****             if (event.pressed) {
 894               		.loc 1 276 44 view .LVU224
 895 0072 C07F      		andi r28,lo8(-16)
 896               	.LVL88:
 276:tmk_core/common/action.c ****             if (event.pressed) {
 897               		.loc 1 276 21 view .LVU225
 898 0074 01F0      		breq .L63
 276:tmk_core/common/action.c ****             if (event.pressed) {
 899               		.loc 1 276 21 discriminator 2 view .LVU226
 900 0076 0295      		swap r16
 901 0078 007F      		andi r16,lo8(-16)
 902               	.L63:
 903               	.LVL89:
 277:tmk_core/common/action.c ****                 if (mods) {
 904               		.loc 1 277 13 is_stmt 1 discriminator 4 view .LVU227
 277:tmk_core/common/action.c ****                 if (mods) {
 905               		.loc 1 277 16 is_stmt 0 discriminator 4 view .LVU228
 906 007a 1123      		tst r17
 907 007c 01F0      		breq .L64
 278:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 908               		.loc 1 278 17 is_stmt 1 view .LVU229
 278:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 909               		.loc 1 278 20 is_stmt 0 view .LVU230
 910 007e 0023      		tst r16
 911 0080 01F0      		breq .L160
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 912               		.loc 1 279 21 is_stmt 1 view .LVU231
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 913               		.loc 1 279 25 is_stmt 0 view .LVU232
 914 0082 80E2      		ldi r24,lo8(32)
 915 0084 8D0F      		add r24,r29
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 916               		.loc 1 279 24 view .LVU233
 917 0086 8830      		cpi r24,lo8(8)
 918 0088 00F0      		brlo .L66
 279:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 919               		.loc 1 279 49 discriminator 1 view .LVU234
 920 008a D111      		cpse r29,__zero_reg__
 921 008c 00C0      		rjmp .L67
 922               	.L66:
 283:tmk_core/common/action.c ****                     } else {
 923               		.loc 1 283 25 is_stmt 1 view .LVU235
 924 008e 802F      		mov r24,r16
 925 0090 0E94 0000 		call add_mods
 926               	.LVL90:
 927               	.L68:
 287:tmk_core/common/action.c ****                 }
 928               		.loc 1 287 21 view .LVU236
 929 0094 0E94 0000 		call send_keyboard_report
 930               	.LVL91:
 289:tmk_core/common/action.c ****             } else {
 931               		.loc 1 289 17 view .LVU237
 932               	.L160:
 289:tmk_core/common/action.c ****             } else {
 933               		.loc 1 289 17 is_stmt 0 view .LVU238
 934               	.LBE44:
 602:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 935               		.loc 1 602 75 is_stmt 1 view .LVU239
 603:tmk_core/common/action.c ****                         } else {
 936               		.loc 1 603 29 view .LVU240
 937 0098 8D2F      		mov r24,r29
 938 009a 0E94 0000 		call register_code
 939               	.LVL92:
 940 009e 00C0      		rjmp .L53
 941               	.LVL93:
 942               	.L67:
 943               	.LBB45:
 285:tmk_core/common/action.c ****                     }
 944               		.loc 1 285 25 view .LVU241
 945 00a0 802F      		mov r24,r16
 946 00a2 0E94 0000 		call add_weak_mods
 947               	.LVL94:
 948 00a6 00C0      		rjmp .L68
 949               	.L64:
 291:tmk_core/common/action.c ****                 if (mods) {
 950               		.loc 1 291 17 view .LVU242
 951 00a8 8D2F      		mov r24,r29
 952 00aa 0E94 0000 		call unregister_code
 953               	.LVL95:
 292:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 954               		.loc 1 292 17 view .LVU243
 292:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 955               		.loc 1 292 20 is_stmt 0 view .LVU244
 956 00ae 0023      		tst r16
 957 00b0 01F0      		breq .L53
 293:tmk_core/common/action.c ****                         del_mods(mods);
 958               		.loc 1 293 21 is_stmt 1 view .LVU245
 293:tmk_core/common/action.c ****                         del_mods(mods);
 959               		.loc 1 293 25 is_stmt 0 view .LVU246
 960 00b2 80E2      		ldi r24,lo8(32)
 961 00b4 8D0F      		add r24,r29
 293:tmk_core/common/action.c ****                         del_mods(mods);
 962               		.loc 1 293 24 view .LVU247
 963 00b6 8830      		cpi r24,lo8(8)
 964 00b8 00F0      		brlo .L70
 293:tmk_core/common/action.c ****                         del_mods(mods);
 965               		.loc 1 293 49 discriminator 1 view .LVU248
 966 00ba D111      		cpse r29,__zero_reg__
 967 00bc 00C0      		rjmp .L71
 968               	.L70:
 294:tmk_core/common/action.c ****                     } else {
 969               		.loc 1 294 25 is_stmt 1 view .LVU249
 970 00be 802F      		mov r24,r16
 971 00c0 0E94 0000 		call del_mods
 972               	.LVL96:
 973               	.L72:
 298:tmk_core/common/action.c ****                 }
 974               		.loc 1 298 21 view .LVU250
 975 00c4 0E94 0000 		call send_keyboard_report
 976               	.LVL97:
 977               	.L53:
 298:tmk_core/common/action.c ****                 }
 978               		.loc 1 298 21 is_stmt 0 view .LVU251
 979               	.LBE45:
 717:tmk_core/common/action.c ****         case ACT_LAYER:
 980               		.loc 1 717 5 is_stmt 1 view .LVU252
 981 00c8 2B2D      		mov r18,r11
 982 00ca 2850      		subi r18,8
 983 00cc 330B      		sbc r19,r19
 984 00ce 2430      		cpi r18,4
 985 00d0 3105      		cpc r19,__zero_reg__
 986 00d2 00F4      		brsh .L123
 724:tmk_core/common/action.c ****             break;
 987               		.loc 1 724 13 view .LVU253
 988 00d4 0E94 0000 		call host_keyboard_leds
 989               	.LVL98:
 990 00d8 0E94 0000 		call led_set
 991               	.LVL99:
 725:tmk_core/common/action.c ****         default:
 992               		.loc 1 725 13 view .LVU254
 993               	.L123:
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 994               		.loc 1 770 5 view .LVU255
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 995               		.loc 1 770 8 is_stmt 0 view .LVU256
 996 00dc EE20      		tst r14
 997 00de 01F4      		brne .+2
 998 00e0 00C0      		rjmp .L49
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 999               		.loc 1 770 33 discriminator 1 view .LVU257
 1000 00e2 0E94 0000 		call get_oneshot_layer_state
 1001               	.LVL100:
 770:tmk_core/common/action.c ****         record->event.pressed = false;
 1002               		.loc 1 770 28 discriminator 1 view .LVU258
 1003 00e6 80FD      		sbrc r24,0
 1004 00e8 00C0      		rjmp .L49
 771:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1005               		.loc 1 771 9 is_stmt 1 view .LVU259
 771:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1006               		.loc 1 771 31 is_stmt 0 view .LVU260
 1007 00ea F601      		movw r30,r12
 1008 00ec 1282      		std Z+2,__zero_reg__
 772:tmk_core/common/action.c ****         process_record(record);
 1009               		.loc 1 772 9 is_stmt 1 view .LVU261
 1010 00ee 0E94 0000 		call get_oneshot_layer
 1011               	.LVL101:
 1012 00f2 0E94 0000 		call layer_on
 1013               	.LVL102:
 773:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1014               		.loc 1 773 9 view .LVU262
 1015 00f6 C601      		movw r24,r12
 1016 00f8 0E94 0000 		call process_record
 1017               	.LVL103:
 774:tmk_core/common/action.c ****     }
 1018               		.loc 1 774 9 view .LVU263
 1019 00fc 0E94 0000 		call get_oneshot_layer
 1020               	.LVL104:
 1021               	/* epilogue start */
 777:tmk_core/common/action.c **** 
 1022               		.loc 1 777 1 is_stmt 0 view .LVU264
 1023 0100 DF91      		pop r29
 1024               	.LVL105:
 777:tmk_core/common/action.c **** 
 1025               		.loc 1 777 1 view .LVU265
 1026 0102 CF91      		pop r28
 777:tmk_core/common/action.c **** 
 1027               		.loc 1 777 1 view .LVU266
 1028 0104 1F91      		pop r17
 1029 0106 0F91      		pop r16
 1030 0108 FF90      		pop r15
 1031 010a EF90      		pop r14
 1032               	.LVL106:
 777:tmk_core/common/action.c **** 
 1033               		.loc 1 777 1 view .LVU267
 1034 010c DF90      		pop r13
 1035 010e CF90      		pop r12
 1036               	.LVL107:
 777:tmk_core/common/action.c **** 
 1037               		.loc 1 777 1 view .LVU268
 1038 0110 BF90      		pop r11
 774:tmk_core/common/action.c ****     }
 1039               		.loc 1 774 9 view .LVU269
 1040 0112 0C94 0000 		jmp layer_off
 1041               	.LVL108:
 1042               	.L71:
 1043               	.LBB46:
 296:tmk_core/common/action.c ****                     }
 1044               		.loc 1 296 25 is_stmt 1 view .LVU270
 1045 0116 802F      		mov r24,r16
 1046 0118 0E94 0000 		call del_weak_mods
 1047               	.LVL109:
 1048 011c 00C0      		rjmp .L72
 1049               	.LVL110:
 1050               	.L61:
 296:tmk_core/common/action.c ****                     }
 1051               		.loc 1 296 25 is_stmt 0 view .LVU271
 1052               	.LBE46:
 1053               	.LBB47:
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1054               		.loc 1 305 13 is_stmt 1 view .LVU272
 1055 011e FC2F      		mov r31,r28
 1056 0120 FF70      		andi r31,lo8(15)
 1057 0122 FF2E      		mov r15,r31
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1058               		.loc 1 305 44 is_stmt 0 view .LVU273
 1059 0124 C07F      		andi r28,lo8(-16)
 1060               	.LVL111:
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1061               		.loc 1 305 21 view .LVU274
 1062 0126 C032      		cpi r28,lo8(32)
 1063 0128 01F0      		breq .L73
 305:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1064               		.loc 1 305 21 discriminator 2 view .LVU275
 1065 012a F294      		swap r15
 1066 012c 80EF      		ldi r24,lo8(-16)
 1067 012e F822      		and r15,r24
 1068               	.L73:
 1069               	.LVL112:
 306:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1070               		.loc 1 306 13 is_stmt 1 discriminator 4 view .LVU276
 1071 0130 DD23      		tst r29
 1072 0132 01F0      		breq .L74
 1073 0134 D130      		cpi r29,lo8(1)
 1074 0136 01F0      		breq .L75
 361:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1075               		.loc 1 361 21 view .LVU277
 361:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1076               		.loc 1 361 24 is_stmt 0 view .LVU278
 1077 0138 1123      		tst r17
 1078 013a 01F0      		breq .L83
 362:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1079               		.loc 1 362 25 is_stmt 1 view .LVU279
 362:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1080               		.loc 1 362 28 is_stmt 0 view .LVU280
 1081 013c 0023      		tst r16
 1082 013e 01F0      		breq .L84
 364:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1083               		.loc 1 364 29 is_stmt 1 view .LVU281
 368:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1084               		.loc 1 368 33 is_stmt 0 view .LVU282
 1085 0140 F601      		movw r30,r12
 1086 0142 8581      		ldd r24,Z+5
 364:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1087               		.loc 1 364 32 view .LVU283
 1088 0144 80FF      		sbrs r24,0
 1089 0146 00C0      		rjmp .L160
 369:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 1090               		.loc 1 369 76 is_stmt 1 view .LVU284
 371:tmk_core/common/action.c ****                                 register_mods(mods);
 1091               		.loc 1 371 33 view .LVU285
 371:tmk_core/common/action.c ****                                 register_mods(mods);
 1092               		.loc 1 371 51 is_stmt 0 view .LVU286
 1093 0148 8F70      		andi r24,lo8(15)
 1094 014a 8583      		std Z+5,r24
 372:tmk_core/common/action.c ****                             } else
 1095               		.loc 1 372 33 is_stmt 1 view .LVU287
 1096 014c 00C0      		rjmp .L84
 1097               	.L74:
 310:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1098               		.loc 1 310 21 view .LVU288
 310:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1099               		.loc 1 310 24 is_stmt 0 view .LVU289
 1100 014e 1123      		tst r17
 1101 0150 01F0      		breq .L77
 311:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1102               		.loc 1 311 25 is_stmt 1 view .LVU290
 311:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1103               		.loc 1 311 28 is_stmt 0 view .LVU291
 1104 0152 0111      		cpse r16,__zero_reg__
 1105 0154 00C0      		rjmp .L78
 1106               	.L79:
 325:tmk_core/common/action.c ****                         }
 1107               		.loc 1 325 29 is_stmt 1 view .LVU292
 325:tmk_core/common/action.c ****                         }
 1108               		.loc 1 325 50 is_stmt 0 view .LVU293
 1109 0156 0E94 0000 		call get_oneshot_mods
 1110               	.LVL113:
 325:tmk_core/common/action.c ****                         }
 1111               		.loc 1 325 29 view .LVU294
 1112 015a 8F29      		or r24,r15
 1113               	.LVL114:
 1114               	.L159:
 325:tmk_core/common/action.c ****                         }
 1115               		.loc 1 325 29 view .LVU295
 1116               	.LBE47:
 529:tmk_core/common/action.c ****             } else {
 1117               		.loc 1 529 17 view .LVU296
 1118 015c 0E94 0000 		call register_mods
 1119               	.LVL115:
 1120 0160 00C0      		rjmp .L53
 1121               	.LVL116:
 1122               	.L78:
 1123               	.LBB50:
 314:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1124               		.loc 1 314 32 is_stmt 1 view .LVU297
 314:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1125               		.loc 1 314 35 is_stmt 0 view .LVU298
 1126 0162 0130      		cpi r16,lo8(1)
 1127 0164 01F4      		brne .L79
 315:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1128               		.loc 1 315 65 is_stmt 1 view .LVU299
 316:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1129               		.loc 1 316 29 view .LVU300
 316:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1130               		.loc 1 316 53 is_stmt 0 view .LVU301
 1131 0166 0E94 0000 		call get_oneshot_mods
 1132               	.LVL117:
 316:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1133               		.loc 1 316 29 view .LVU302
 1134 016a 8F29      		or r24,r15
 1135 016c 0E94 0000 		call set_oneshot_mods
 1136               	.LVL118:
 1137 0170 00C0      		rjmp .L53
 1138               	.L77:
 328:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1139               		.loc 1 328 25 is_stmt 1 view .LVU303
 328:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1140               		.loc 1 328 28 is_stmt 0 view .LVU304
 1141 0172 0111      		cpse r16,__zero_reg__
 1142 0174 00C0      		rjmp .L80
 1143               	.L162:
 343:tmk_core/common/action.c ****                             unregister_mods(mods);
 1144               		.loc 1 343 29 is_stmt 1 view .LVU305
 1145 0176 0E94 0000 		call clear_oneshot_mods
 1146               	.LVL119:
 344:tmk_core/common/action.c ****                         }
 1147               		.loc 1 344 29 view .LVU306
 1148               	.L86:
 393:tmk_core/common/action.c ****                             unregister_mods(mods);
 1149               		.loc 1 393 67 view .LVU307
 394:tmk_core/common/action.c ****                         }
 1150               		.loc 1 394 29 view .LVU308
 1151 017a 8F2D      		mov r24,r15
 1152 017c 0E94 0000 		call unregister_mods
 1153               	.LVL120:
 1154 0180 00C0      		rjmp .L53
 1155               	.L80:
 331:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1156               		.loc 1 331 32 view .LVU309
 331:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1157               		.loc 1 331 35 is_stmt 0 view .LVU310
 1158 0182 0130      		cpi r16,lo8(1)
 1159 0184 01F4      		brne .+2
 1160 0186 00C0      		rjmp .L53
 1161 0188 00C0      		rjmp .L162
 1162               	.L75:
 350:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1163               		.loc 1 350 21 is_stmt 1 view .LVU311
 350:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1164               		.loc 1 350 24 is_stmt 0 view .LVU312
 1165 018a 1123      		tst r17
 1166 018c 01F0      		breq .L82
 351:tmk_core/common/action.c ****                             register_mods(mods);
 1167               		.loc 1 351 25 is_stmt 1 view .LVU313
 351:tmk_core/common/action.c ****                             register_mods(mods);
 1168               		.loc 1 351 28 is_stmt 0 view .LVU314
 1169 018e 0630      		cpi r16,lo8(6)
 1170 0190 00F0      		brlo .+2
 1171 0192 00C0      		rjmp .L53
 1172               	.L84:
 380:tmk_core/common/action.c ****                             register_mods(mods);
 1173               		.loc 1 380 67 is_stmt 1 view .LVU315
 381:tmk_core/common/action.c ****                         }
 1174               		.loc 1 381 29 view .LVU316
 1175 0194 8F2D      		mov r24,r15
 1176 0196 00C0      		rjmp .L159
 1177               	.L82:
 355:tmk_core/common/action.c ****                             unregister_mods(mods);
 1178               		.loc 1 355 25 view .LVU317
 355:tmk_core/common/action.c ****                             unregister_mods(mods);
 1179               		.loc 1 355 28 is_stmt 0 view .LVU318
 1180 0198 0530      		cpi r16,lo8(5)
 1181 019a 00F0      		brlo .+2
 1182 019c 00C0      		rjmp .L53
 1183 019e 00C0      		rjmp .L86
 1184               	.L83:
 384:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1185               		.loc 1 384 25 is_stmt 1 view .LVU319
 384:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1186               		.loc 1 384 28 is_stmt 0 view .LVU320
 1187 01a0 0023      		tst r16
 1188 01a2 01F0      		breq .L86
 385:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1189               		.loc 1 385 71 is_stmt 1 view .LVU321
 386:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1190               		.loc 1 386 29 view .LVU322
 386:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1191               		.loc 1 386 32 is_stmt 0 view .LVU323
 1192 01a4 D933      		cpi r29,lo8(57)
 1193 01a6 01F4      		brne .L122
 387:tmk_core/common/action.c ****                             } else {
 1194               		.loc 1 387 33 is_stmt 1 view .LVU324
 1195               	.LVL121:
 1196               	.LBB48:
 1197               	.LBI48:
 166:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** {
 1198               		.loc 2 166 1 view .LVU325
 1199               	.LBB49:
 168:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1200               		.loc 2 168 2 view .LVU326
 172:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1201               		.loc 2 172 2 view .LVU327
 173:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1202               		.loc 2 173 2 view .LVU328
 174:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 1203               		.loc 2 174 2 view .LVU329
 184:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 1204               		.loc 2 184 3 view .LVU330
 1205               		.loc 2 187 2 view .LVU331
 1206 01a8 FFEF      		ldi r31,lo8(127999)
 1207 01aa 23EF      		ldi r18,hi8(127999)
 1208 01ac 31E0      		ldi r19,hlo8(127999)
 1209 01ae F150      	1:	subi r31,1
 1210 01b0 2040      		sbci r18,0
 1211 01b2 3040      		sbci r19,0
 1212 01b4 01F4      		brne 1b
 1213               	.LVL122:
 1214               	.L163:
 1215               		.loc 2 187 2 is_stmt 0 view .LVU332
 1216               	.LBE49:
 1217               	.LBE48:
 1218               	.LBE50:
 1219               	.LBB51:
 1220               	.LBB52:
 1221 01b6 00C0      		rjmp .
 1222 01b8 0000      		nop
 1223               	.L122:
 1224               	.LBE52:
 1225               	.LBE51:
 616:tmk_core/common/action.c ****                         } else {
 1226               		.loc 1 616 29 is_stmt 1 view .LVU333
 1227 01ba 8D2F      		mov r24,r29
 1228 01bc 0E94 0000 		call unregister_code
 1229               	.LVL123:
 1230 01c0 00C0      		rjmp .L53
 1231               	.L60:
 404:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1232               		.loc 1 404 13 view .LVU334
 404:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1233               		.loc 1 404 33 is_stmt 0 view .LVU335
 1234 01c2 8C2F      		mov r24,r28
 1235 01c4 8695      		lsr r24
 1236 01c6 8695      		lsr r24
 1237 01c8 8370      		andi r24,lo8(3)
 1238 01ca 01F0      		breq .L89
 1239 01cc 8130      		cpi r24,lo8(1)
 1240 01ce 01F0      		breq .+2
 1241 01d0 00C0      		rjmp .L53
 413:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1242               		.loc 1 413 21 is_stmt 1 view .LVU336
 414:tmk_core/common/action.c ****                     } else {
 1243               		.loc 1 414 25 is_stmt 0 view .LVU337
 1244 01d2 8D2F      		mov r24,r29
 1245 01d4 9C2F      		mov r25,r28
 1246 01d6 9370      		andi r25,lo8(3)
 413:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1247               		.loc 1 413 24 view .LVU338
 1248 01d8 1111      		cpse r17,__zero_reg__
 1249 01da 00C0      		rjmp .L161
 416:tmk_core/common/action.c ****                     }
 1250               		.loc 1 416 25 is_stmt 1 view .LVU339
 1251 01dc 90E0      		ldi r25,0
 1252 01de 80E0      		ldi r24,0
 1253               	.L161:
 1254 01e0 0E94 0000 		call host_consumer_send
 1255               	.LVL124:
 1256 01e4 00C0      		rjmp .L53
 1257               	.L89:
 406:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1258               		.loc 1 406 21 view .LVU340
 407:tmk_core/common/action.c ****                     } else {
 1259               		.loc 1 407 25 is_stmt 0 view .LVU341
 1260 01e6 8D2F      		mov r24,r29
 1261 01e8 9C2F      		mov r25,r28
 1262 01ea 9370      		andi r25,lo8(3)
 406:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1263               		.loc 1 406 24 view .LVU342
 1264 01ec 1111      		cpse r17,__zero_reg__
 1265 01ee 00C0      		rjmp .L157
 409:tmk_core/common/action.c ****                     }
 1266               		.loc 1 409 25 is_stmt 1 view .LVU343
 1267 01f0 90E0      		ldi r25,0
 1268 01f2 80E0      		ldi r24,0
 1269               	.L157:
 1270 01f4 0E94 0000 		call host_system_send
 1271               	.LVL125:
 1272 01f8 00C0      		rjmp .L53
 1273               	.L59:
 482:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1274               		.loc 1 482 13 view .LVU344
 482:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1275               		.loc 1 482 39 is_stmt 0 view .LVU345
 1276 01fa 8C2F      		mov r24,r28
 1277 01fc 8370      		andi r24,lo8(3)
 482:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1278               		.loc 1 482 16 view .LVU346
 1279 01fe 01F0      		breq .+2
 1280 0200 00C0      		rjmp .L93
 484:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1281               		.loc 1 484 17 is_stmt 1 view .LVU347
 484:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1282               		.loc 1 484 20 is_stmt 0 view .LVU348
 1283 0202 1111      		cpse r17,__zero_reg__
 1284 0204 00C0      		rjmp .L53
 1285               	.LBB54:
 485:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1286               		.loc 1 485 21 is_stmt 1 view .LVU349
 1287               	.LVL126:
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1288               		.loc 1 486 21 view .LVU350
 485:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1289               		.loc 1 485 61 is_stmt 0 view .LVU351
 1290 0206 4D2F      		mov r20,r29
 1291 0208 4295      		swap r20
 1292 020a 4695      		lsr r20
 1293 020c 4770      		andi r20,lo8(7)
 485:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1294               		.loc 1 485 35 view .LVU352
 1295 020e 440F      		lsl r20
 1296 0210 440F      		lsl r20
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1297               		.loc 1 486 77 view .LVU353
 1298 0212 0D2F      		mov r16,r29
 1299               	.LVL127:
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1300               		.loc 1 486 77 view .LVU354
 1301 0214 0F70      		andi r16,lo8(15)
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1302               		.loc 1 486 44 view .LVU355
 1303 0216 10E0      		ldi r17,0
 1304               	.LVL128:
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1305               		.loc 1 486 44 view .LVU356
 1306 0218 30E0      		ldi r19,0
 1307 021a 20E0      		ldi r18,0
 486:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1308               		.loc 1 486 35 view .LVU357
 1309 021c 042E      		mov r0,r20
 1310 021e 00C0      		rjmp 2f
 1311               		1:
 1312 0220 000F      		lsl r16
 1313 0222 111F      		rol r17
 1314 0224 221F      		rol r18
 1315 0226 331F      		rol r19
 1316               		2:
 1317 0228 0A94      		dec r0
 1318 022a 02F4      		brpl 1b
 1319               	.LVL129:
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1320               		.loc 1 487 21 is_stmt 1 view .LVU358
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1321               		.loc 1 487 104 is_stmt 0 view .LVU359
 1322 022c 60E0      		ldi r22,0
 1323 022e 70E0      		ldi r23,0
 1324 0230 CB01      		movw r24,r22
 1325 0232 D4FF      		sbrs r29,4
 1326 0234 00C0      		rjmp .L94
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1327               		.loc 1 487 94 discriminator 1 view .LVU360
 1328 0236 6FE0      		ldi r22,lo8(15)
 1329 0238 70E0      		ldi r23,0
 1330 023a 80E0      		ldi r24,0
 1331 023c 90E0      		ldi r25,0
 1332 023e 00C0      		rjmp 2f
 1333               		1:
 1334 0240 660F      		lsl r22
 1335 0242 771F      		rol r23
 1336 0244 881F      		rol r24
 1337 0246 991F      		rol r25
 1338               		2:
 1339 0248 4A95      		dec r20
 1340 024a 02F4      		brpl 1b
 487:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1341               		.loc 1 487 104 discriminator 1 view .LVU361
 1342 024c 6095      		com r22
 1343 024e 7095      		com r23
 1344 0250 8095      		com r24
 1345 0252 9095      		com r25
 1346               	.L94:
 1347               	.LVL130:
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1348               		.loc 1 488 21 is_stmt 1 discriminator 4 view .LVU362
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1349               		.loc 1 488 47 is_stmt 0 discriminator 4 view .LVU363
 1350 0254 C695      		lsr r28
 1351 0256 C695      		lsr r28
 1352               	.LVL131:
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1353               		.loc 1 488 47 discriminator 4 view .LVU364
 1354 0258 C370      		andi r28,lo8(3)
 1355 025a 602B      		or r22,r16
 1356               	.LVL132:
 488:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1357               		.loc 1 488 47 discriminator 4 view .LVU365
 1358 025c 712B      		or r23,r17
 1359 025e 822B      		or r24,r18
 1360 0260 932B      		or r25,r19
 1361 0262 C230      		cpi r28,lo8(2)
 1362 0264 01F0      		breq .L95
 1363 0266 00F4      		brsh .L96
 1364 0268 C130      		cpi r28,lo8(1)
 1365 026a 01F0      		breq .L97
 490:tmk_core/common/action.c ****                             break;
 1366               		.loc 1 490 29 is_stmt 1 view .LVU366
 1367 026c 0E94 0000 		call default_layer_and
 1368               	.LVL133:
 491:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1369               		.loc 1 491 29 view .LVU367
 1370 0270 00C0      		rjmp .L53
 1371               	.L97:
 493:tmk_core/common/action.c ****                             break;
 1372               		.loc 1 493 29 view .LVU368
 1373 0272 0E94 0000 		call default_layer_or
 1374               	.LVL134:
 494:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1375               		.loc 1 494 29 view .LVU369
 1376 0276 00C0      		rjmp .L53
 1377               	.L95:
 496:tmk_core/common/action.c ****                             break;
 1378               		.loc 1 496 29 view .LVU370
 1379 0278 0E94 0000 		call default_layer_xor
 1380               	.LVL135:
 497:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1381               		.loc 1 497 29 view .LVU371
 1382 027c 00C0      		rjmp .L53
 1383               	.L96:
 499:tmk_core/common/action.c ****                             break;
 1384               		.loc 1 499 29 view .LVU372
 1385 027e 0E94 0000 		call default_layer_set
 1386               	.LVL136:
 500:tmk_core/common/action.c ****                     }
 1387               		.loc 1 500 29 view .LVU373
 1388 0282 00C0      		rjmp .L53
 1389               	.LVL137:
 1390               	.L93:
 500:tmk_core/common/action.c ****                     }
 1391               		.loc 1 500 29 is_stmt 0 view .LVU374
 1392               	.LBE54:
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1393               		.loc 1 505 17 is_stmt 1 view .LVU375
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1394               		.loc 1 505 21 is_stmt 0 view .LVU376
 1395 0284 8695      		lsr r24
 1396 0286 1123      		tst r17
 1397 0288 01F0      		breq .L99
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1398               		.loc 1 505 21 discriminator 1 view .LVU377
 1399 028a 8C2F      		mov r24,r28
 1400 028c 8170      		andi r24,lo8(1)
 1401               	.L99:
 505:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1402               		.loc 1 505 20 discriminator 4 view .LVU378
 1403 028e 8823      		tst r24
 1404 0290 01F4      		brne .+2
 1405 0292 00C0      		rjmp .L53
 1406               	.LBB55:
 506:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1407               		.loc 1 506 21 is_stmt 1 view .LVU379
 1408               	.LVL138:
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1409               		.loc 1 507 21 view .LVU380
 506:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1410               		.loc 1 506 61 is_stmt 0 view .LVU381
 1411 0294 4D2F      		mov r20,r29
 1412 0296 4295      		swap r20
 1413 0298 4695      		lsr r20
 1414 029a 4770      		andi r20,lo8(7)
 506:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1415               		.loc 1 506 35 view .LVU382
 1416 029c 440F      		lsl r20
 1417 029e 440F      		lsl r20
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1418               		.loc 1 507 77 view .LVU383
 1419 02a0 0D2F      		mov r16,r29
 1420               	.LVL139:
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1421               		.loc 1 507 77 view .LVU384
 1422 02a2 0F70      		andi r16,lo8(15)
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1423               		.loc 1 507 44 view .LVU385
 1424 02a4 10E0      		ldi r17,0
 1425               	.LVL140:
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1426               		.loc 1 507 44 view .LVU386
 1427 02a6 30E0      		ldi r19,0
 1428 02a8 20E0      		ldi r18,0
 507:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1429               		.loc 1 507 35 view .LVU387
 1430 02aa 042E      		mov r0,r20
 1431 02ac 00C0      		rjmp 2f
 1432               		1:
 1433 02ae 000F      		lsl r16
 1434 02b0 111F      		rol r17
 1435 02b2 221F      		rol r18
 1436 02b4 331F      		rol r19
 1437               		2:
 1438 02b6 0A94      		dec r0
 1439 02b8 02F4      		brpl 1b
 1440               	.LVL141:
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1441               		.loc 1 508 21 is_stmt 1 view .LVU388
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1442               		.loc 1 508 104 is_stmt 0 view .LVU389
 1443 02ba 60E0      		ldi r22,0
 1444 02bc 70E0      		ldi r23,0
 1445 02be CB01      		movw r24,r22
 1446 02c0 D4FF      		sbrs r29,4
 1447 02c2 00C0      		rjmp .L100
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1448               		.loc 1 508 94 discriminator 1 view .LVU390
 1449 02c4 6FE0      		ldi r22,lo8(15)
 1450 02c6 70E0      		ldi r23,0
 1451 02c8 80E0      		ldi r24,0
 1452 02ca 90E0      		ldi r25,0
 1453 02cc 00C0      		rjmp 2f
 1454               		1:
 1455 02ce 660F      		lsl r22
 1456 02d0 771F      		rol r23
 1457 02d2 881F      		rol r24
 1458 02d4 991F      		rol r25
 1459               		2:
 1460 02d6 4A95      		dec r20
 1461 02d8 02F4      		brpl 1b
 508:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1462               		.loc 1 508 104 discriminator 1 view .LVU391
 1463 02da 6095      		com r22
 1464 02dc 7095      		com r23
 1465 02de 8095      		com r24
 1466 02e0 9095      		com r25
 1467               	.L100:
 1468               	.LVL142:
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1469               		.loc 1 509 21 is_stmt 1 discriminator 4 view .LVU392
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1470               		.loc 1 509 47 is_stmt 0 discriminator 4 view .LVU393
 1471 02e2 C695      		lsr r28
 1472 02e4 C695      		lsr r28
 1473               	.LVL143:
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1474               		.loc 1 509 47 discriminator 4 view .LVU394
 1475 02e6 C370      		andi r28,lo8(3)
 1476 02e8 602B      		or r22,r16
 1477               	.LVL144:
 509:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1478               		.loc 1 509 47 discriminator 4 view .LVU395
 1479 02ea 712B      		or r23,r17
 1480 02ec 822B      		or r24,r18
 1481 02ee 932B      		or r25,r19
 1482 02f0 C230      		cpi r28,lo8(2)
 1483 02f2 01F0      		breq .L101
 1484 02f4 00F4      		brsh .L102
 1485 02f6 C130      		cpi r28,lo8(1)
 1486 02f8 01F0      		breq .L103
 511:tmk_core/common/action.c ****                             break;
 1487               		.loc 1 511 29 is_stmt 1 view .LVU396
 1488 02fa 0E94 0000 		call layer_and
 1489               	.LVL145:
 512:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1490               		.loc 1 512 29 view .LVU397
 1491 02fe 00C0      		rjmp .L53
 1492               	.L103:
 514:tmk_core/common/action.c ****                             break;
 1493               		.loc 1 514 29 view .LVU398
 1494 0300 0E94 0000 		call layer_or
 1495               	.LVL146:
 515:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1496               		.loc 1 515 29 view .LVU399
 1497 0304 00C0      		rjmp .L53
 1498               	.L101:
 517:tmk_core/common/action.c ****                             break;
 1499               		.loc 1 517 29 view .LVU400
 1500 0306 0E94 0000 		call layer_xor
 1501               	.LVL147:
 518:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1502               		.loc 1 518 29 view .LVU401
 1503 030a 00C0      		rjmp .L53
 1504               	.L102:
 520:tmk_core/common/action.c ****                             break;
 1505               		.loc 1 520 29 view .LVU402
 1506 030c 0E94 0000 		call layer_state_set
 1507               	.LVL148:
 521:tmk_core/common/action.c ****                     }
 1508               		.loc 1 521 29 view .LVU403
 1509 0310 00C0      		rjmp .L53
 1510               	.LVL149:
 1511               	.L58:
 521:tmk_core/common/action.c ****                     }
 1512               		.loc 1 521 29 is_stmt 0 view .LVU404
 1513               	.LBE55:
 527:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1514               		.loc 1 527 13 is_stmt 1 view .LVU405
 1515 0312 CF70      		andi r28,lo8(15)
 1516               	.LVL150:
 527:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1517               		.loc 1 527 16 is_stmt 0 view .LVU406
 1518 0314 1123      		tst r17
 1519 0316 01F0      		breq .L104
 528:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1520               		.loc 1 528 17 is_stmt 1 view .LVU407
 1521 0318 8C2F      		mov r24,r28
 1522 031a 0E94 0000 		call layer_on
 1523               	.LVL151:
 529:tmk_core/common/action.c ****             } else {
 1524               		.loc 1 529 17 view .LVU408
 1525 031e 8D2F      		mov r24,r29
 1526 0320 00C0      		rjmp .L159
 1527               	.L104:
 531:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1528               		.loc 1 531 17 view .LVU409
 1529 0322 8D2F      		mov r24,r29
 1530 0324 0E94 0000 		call unregister_mods
 1531               	.LVL152:
 532:tmk_core/common/action.c ****             }
 1532               		.loc 1 532 17 view .LVU410
 1533 0328 8C2F      		mov r24,r28
 1534               	.LVL153:
 1535               	.L156:
 619:tmk_core/common/action.c ****                         }
 1536               		.loc 1 619 29 is_stmt 0 view .LVU411
 1537 032a 0E94 0000 		call layer_off
 1538               	.LVL154:
 1539 032e 00C0      		rjmp .L53
 1540               	.L57:
 538:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1541               		.loc 1 538 13 is_stmt 1 view .LVU412
 1542 0330 D23F      		cpi r29,lo8(-14)
 1543 0332 01F0      		breq .L105
 1544 0334 00F4      		brsh .L106
 1545 0336 D03F      		cpi r29,lo8(-16)
 1546 0338 01F0      		breq .L107
 1547 033a D13F      		cpi r29,lo8(-15)
 1548 033c 01F0      		breq .L108
 1549               	.L109:
 600:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1550               		.loc 1 600 21 view .LVU413
 600:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1551               		.loc 1 600 24 is_stmt 0 view .LVU414
 1552 033e 1123      		tst r17
 1553 0340 01F4      		brne .+2
 1554 0342 00C0      		rjmp .L118
 601:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1555               		.loc 1 601 25 is_stmt 1 view .LVU415
 601:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1556               		.loc 1 601 28 is_stmt 0 view .LVU416
 1557 0344 0111      		cpse r16,__zero_reg__
 1558 0346 00C0      		rjmp .L160
 605:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1559               		.loc 1 605 76 is_stmt 1 view .LVU417
 606:tmk_core/common/action.c ****                         }
 1560               		.loc 1 606 29 view .LVU418
 1561 0348 8C2F      		mov r24,r28
 1562 034a 8F71      		andi r24,lo8(31)
 1563 034c 00C0      		rjmp .L158
 1564               	.L106:
 1565 034e D33F      		cpi r29,lo8(-13)
 1566 0350 01F0      		breq .L110
 1567 0352 D43F      		cpi r29,lo8(-12)
 1568 0354 01F4      		brne .L109
 586:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1569               		.loc 1 586 21 view .LVU419
 586:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1570               		.loc 1 586 24 is_stmt 0 view .LVU420
 1571 0356 1123      		tst r17
 1572 0358 01F0      		breq .L117
 587:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1573               		.loc 1 587 25 is_stmt 1 view .LVU421
 587:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1574               		.loc 1 587 50 is_stmt 0 view .LVU422
 1575 035a CF71      		andi r28,lo8(31)
 1576               	.LVL155:
 587:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1577               		.loc 1 587 25 view .LVU423
 1578 035c 8C2F      		mov r24,r28
 1579 035e 0E94 0000 		call layer_on
 1580               	.LVL156:
 588:tmk_core/common/action.c ****                     } else {
 1581               		.loc 1 588 25 is_stmt 1 view .LVU424
 1582 0362 63E0      		ldi r22,lo8(3)
 1583 0364 8C2F      		mov r24,r28
 1584 0366 0E94 0000 		call set_oneshot_layer
 1585               	.LVL157:
 1586 036a 00C0      		rjmp .L53
 1587               	.LVL158:
 1588               	.L107:
 541:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1589               		.loc 1 541 21 view .LVU425
 541:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1590               		.loc 1 541 24 is_stmt 0 view .LVU426
 1591 036c 1123      		tst r17
 1592 036e 01F0      		breq .L112
 542:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1593               		.loc 1 542 25 is_stmt 1 view .LVU427
 542:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1594               		.loc 1 542 28 is_stmt 0 view .LVU428
 1595 0370 0530      		cpi r16,lo8(5)
 1596 0372 00F0      		brlo .+2
 1597 0374 00C0      		rjmp .L53
 1598               	.L113:
 543:tmk_core/common/action.c ****                         }
 1599               		.loc 1 543 29 is_stmt 1 view .LVU429
 1600 0376 8C2F      		mov r24,r28
 1601 0378 8F71      		andi r24,lo8(31)
 1602 037a 0E94 0000 		call layer_invert
 1603               	.LVL159:
 1604 037e 00C0      		rjmp .L53
 1605               	.L112:
 546:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1606               		.loc 1 546 25 view .LVU430
 546:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1607               		.loc 1 546 28 is_stmt 0 view .LVU431
 1608 0380 0630      		cpi r16,lo8(6)
 1609 0382 00F0      		brlo .+2
 1610 0384 00C0      		rjmp .L53
 1611 0386 00C0      		rjmp .L113
 1612               	.L108:
 552:tmk_core/common/action.c ****                     break;
 1613               		.loc 1 552 21 is_stmt 1 view .LVU432
 1614 0388 8C2F      		mov r24,r28
 1615 038a 8F71      		andi r24,lo8(31)
 552:tmk_core/common/action.c ****                     break;
 1616               		.loc 1 552 68 is_stmt 0 view .LVU433
 1617 038c 1123      		tst r17
 1618 038e 01F0      		breq .L156
 1619               	.L158:
 606:tmk_core/common/action.c ****                         }
 1620               		.loc 1 606 29 view .LVU434
 1621 0390 0E94 0000 		call layer_on
 1622               	.LVL160:
 1623 0394 00C0      		rjmp .L53
 1624               	.L105:
 555:tmk_core/common/action.c ****                     break;
 1625               		.loc 1 555 21 is_stmt 1 view .LVU435
 1626 0396 8C2F      		mov r24,r28
 1627 0398 8F71      		andi r24,lo8(31)
 555:tmk_core/common/action.c ****                     break;
 1628               		.loc 1 555 69 is_stmt 0 view .LVU436
 1629 039a 1123      		tst r17
 1630 039c 01F0      		breq .L158
 1631 039e 00C0      		rjmp .L156
 1632               	.L110:
 558:tmk_core/common/action.c ****                     break;
 1633               		.loc 1 558 21 is_stmt 1 view .LVU437
 558:tmk_core/common/action.c ****                     break;
 1634               		.loc 1 558 70 is_stmt 0 view .LVU438
 1635 03a0 1123      		tst r17
 1636 03a2 01F0      		breq .L116
 558:tmk_core/common/action.c ****                     break;
 1637               		.loc 1 558 37 discriminator 1 view .LVU439
 1638 03a4 8C2F      		mov r24,r28
 1639 03a6 8F71      		andi r24,lo8(31)
 1640 03a8 0E94 0000 		call layer_move
 1641               	.LVL161:
 1642 03ac 00C0      		rjmp .L53
 1643               	.L116:
 558:tmk_core/common/action.c ****                     break;
 1644               		.loc 1 558 72 discriminator 2 view .LVU440
 1645 03ae 0E94 0000 		call layer_clear
 1646               	.LVL162:
 1647 03b2 00C0      		rjmp .L53
 1648               	.L117:
 590:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1649               		.loc 1 590 25 is_stmt 1 view .LVU441
 1650 03b4 81E0      		ldi r24,lo8(1)
 1651 03b6 0E94 0000 		call clear_oneshot_layer_state
 1652               	.LVL163:
 591:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1653               		.loc 1 591 25 view .LVU442
 591:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1654               		.loc 1 591 28 is_stmt 0 view .LVU443
 1655 03ba 0230      		cpi r16,lo8(2)
 1656 03bc 00F4      		brsh .+2
 1657 03be 00C0      		rjmp .L53
 592:tmk_core/common/action.c ****                         }
 1658               		.loc 1 592 29 is_stmt 1 view .LVU444
 1659 03c0 82E0      		ldi r24,lo8(2)
 1660 03c2 0E94 0000 		call clear_oneshot_layer_state
 1661               	.LVL164:
 1662 03c6 00C0      		rjmp .L53
 1663               	.L118:
 609:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1664               		.loc 1 609 25 view .LVU445
 609:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1665               		.loc 1 609 28 is_stmt 0 view .LVU446
 1666 03c8 0023      		tst r16
 1667 03ca 01F0      		breq .L120
 610:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1668               		.loc 1 610 77 is_stmt 1 view .LVU447
 611:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1669               		.loc 1 611 29 view .LVU448
 611:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1670               		.loc 1 611 32 is_stmt 0 view .LVU449
 1671 03cc D933      		cpi r29,lo8(57)
 1672 03ce 01F0      		breq .+2
 1673 03d0 00C0      		rjmp .L122
 612:tmk_core/common/action.c ****                             } else {
 1674               		.loc 1 612 33 is_stmt 1 view .LVU450
 1675               	.LVL165:
 1676               	.LBB56:
 1677               	.LBI51:
 166:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** {
 1678               		.loc 2 166 1 view .LVU451
 1679               	.LBB53:
 168:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1680               		.loc 2 168 2 view .LVU452
 172:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1681               		.loc 2 172 2 view .LVU453
 173:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1682               		.loc 2 173 2 view .LVU454
 174:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 
 1683               		.loc 2 174 2 view .LVU455
 184:c:\program files\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 1684               		.loc 2 184 3 view .LVU456
 1685               		.loc 2 187 2 view .LVU457
 1686 03d2 8FEF      		ldi r24,lo8(127999)
 1687 03d4 93EF      		ldi r25,hi8(127999)
 1688 03d6 E1E0      		ldi r30,hlo8(127999)
 1689 03d8 8150      	1:	subi r24,1
 1690 03da 9040      		sbci r25,0
 1691 03dc E040      		sbci r30,0
 1692 03de 01F4      		brne 1b
 1693 03e0 00C0      		rjmp .L163
 1694               	.LVL166:
 1695               	.L120:
 1696               		.loc 2 187 2 is_stmt 0 view .LVU458
 1697               	.LBE53:
 1698               	.LBE56:
 618:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1699               		.loc 1 618 79 is_stmt 1 view .LVU459
 619:tmk_core/common/action.c ****                         }
 1700               		.loc 1 619 29 view .LVU460
 1701 03e2 8C2F      		mov r24,r28
 1702 03e4 8F71      		andi r24,lo8(31)
 1703 03e6 00C0      		rjmp .L156
 1704               	.L56:
 630:tmk_core/common/action.c ****             break;
 1705               		.loc 1 630 13 view .LVU461
 630:tmk_core/common/action.c ****             break;
 1706               		.loc 1 630 83 is_stmt 0 view .LVU462
 1707 03e8 4C2F      		mov r20,r28
 1708 03ea 4F70      		andi r20,lo8(15)
 630:tmk_core/common/action.c ****             break;
 1709               		.loc 1 630 13 view .LVU463
 1710 03ec 6D2F      		mov r22,r29
 1711 03ee C601      		movw r24,r12
 1712 03f0 0E94 0000 		call action_get_macro
 1713               	.LVL167:
 1714 03f4 0E94 0000 		call action_macro_play
 1715               	.LVL168:
 631:tmk_core/common/action.c **** #endif
 1716               		.loc 1 631 13 is_stmt 1 view .LVU464
 1717 03f8 00C0      		rjmp .L53
 1718               	.L54:
 708:tmk_core/common/action.c ****             break;
 1719               		.loc 1 708 13 view .LVU465
 708:tmk_core/common/action.c ****             break;
 1720               		.loc 1 708 64 is_stmt 0 view .LVU466
 1721 03fa 4C2F      		mov r20,r28
 1722 03fc 4F70      		andi r20,lo8(15)
 708:tmk_core/common/action.c ****             break;
 1723               		.loc 1 708 13 view .LVU467
 1724 03fe 6D2F      		mov r22,r29
 1725 0400 C601      		movw r24,r12
 1726 0402 0E94 0000 		call action_function
 1727               	.LVL169:
 709:tmk_core/common/action.c **** #endif
 1728               		.loc 1 709 13 is_stmt 1 view .LVU468
 1729 0406 00C0      		rjmp .L53
 1730               	.LVL170:
 1731               	.L49:
 1732               	/* epilogue start */
 777:tmk_core/common/action.c **** 
 1733               		.loc 1 777 1 is_stmt 0 view .LVU469
 1734 0408 DF91      		pop r29
 1735               	.LVL171:
 777:tmk_core/common/action.c **** 
 1736               		.loc 1 777 1 view .LVU470
 1737 040a CF91      		pop r28
 777:tmk_core/common/action.c **** 
 1738               		.loc 1 777 1 view .LVU471
 1739 040c 1F91      		pop r17
 1740 040e 0F91      		pop r16
 1741 0410 FF90      		pop r15
 1742 0412 EF90      		pop r14
 1743               	.LVL172:
 777:tmk_core/common/action.c **** 
 1744               		.loc 1 777 1 view .LVU472
 1745 0414 DF90      		pop r13
 1746 0416 CF90      		pop r12
 1747               	.LVL173:
 777:tmk_core/common/action.c **** 
 1748               		.loc 1 777 1 view .LVU473
 1749 0418 BF90      		pop r11
 1750 041a 0895      		ret
 1751               		.cfi_endproc
 1752               	.LFE115:
 1754               		.section	.text.process_record_handler,"ax",@progbits
 1755               	.global	process_record_handler
 1757               	process_record_handler:
 1758               	.LVL174:
 1759               	.LFB114:
 216:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1760               		.loc 1 216 50 is_stmt 1 view -0
 1761               		.cfi_startproc
 216:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1762               		.loc 1 216 50 is_stmt 0 view .LVU475
 1763 0000 0F93      		push r16
 1764               	.LCFI15:
 1765               		.cfi_def_cfa_offset 3
 1766               		.cfi_offset 16, -2
 1767 0002 1F93      		push r17
 1768               	.LCFI16:
 1769               		.cfi_def_cfa_offset 4
 1770               		.cfi_offset 17, -3
 1771 0004 CF93      		push r28
 1772               	.LCFI17:
 1773               		.cfi_def_cfa_offset 5
 1774               		.cfi_offset 28, -4
 1775 0006 DF93      		push r29
 1776               	.LCFI18:
 1777               		.cfi_def_cfa_offset 6
 1778               		.cfi_offset 29, -5
 1779               	/* prologue: function */
 1780               	/* frame size = 0 */
 1781               	/* stack size = 4 */
 1782               	.L__stack_usage = 4
 1783 0008 EC01      		movw r28,r24
 217:tmk_core/common/action.c ****     dprint("ACTION: ");
 1784               		.loc 1 217 5 is_stmt 1 view .LVU476
 217:tmk_core/common/action.c ****     dprint("ACTION: ");
 1785               		.loc 1 217 23 is_stmt 0 view .LVU477
 1786 000a 6881      		ld r22,Y
 1787 000c 7981      		ldd r23,Y+1
 1788 000e 8A81      		ldd r24,Y+2
 1789               	.LVL175:
 217:tmk_core/common/action.c ****     dprint("ACTION: ");
 1790               		.loc 1 217 23 view .LVU478
 1791 0010 0E94 0000 		call store_or_get_action
 1792               	.LVL176:
 1793 0014 8C01      		movw r16,r24
 1794               	.LVL177:
 218:tmk_core/common/action.c ****     debug_action(action);
 1795               		.loc 1 218 23 is_stmt 1 view .LVU479
 219:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1796               		.loc 1 219 5 view .LVU480
 221:tmk_core/common/action.c ****     layer_debug();
 1797               		.loc 1 221 29 view .LVU481
 222:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1798               		.loc 1 222 5 view .LVU482
 1799 0016 0E94 0000 		call layer_debug
 1800               	.LVL178:
 223:tmk_core/common/action.c ****     default_layer_debug();
 1801               		.loc 1 223 37 view .LVU483
 224:tmk_core/common/action.c **** #endif
 1802               		.loc 1 224 5 view .LVU484
 1803 001a 0E94 0000 		call default_layer_debug
 1804               	.LVL179:
 226:tmk_core/common/action.c **** 
 1805               		.loc 1 226 15 view .LVU485
 228:tmk_core/common/action.c **** }
 1806               		.loc 1 228 5 view .LVU486
 228:tmk_core/common/action.c **** }
 1807               		.loc 1 228 5 is_stmt 0 view .LVU487
 1808 001e B801      		movw r22,r16
 1809 0020 CE01      		movw r24,r28
 1810               	/* epilogue start */
 229:tmk_core/common/action.c **** 
 1811               		.loc 1 229 1 view .LVU488
 1812 0022 DF91      		pop r29
 1813 0024 CF91      		pop r28
 1814               	.LVL180:
 229:tmk_core/common/action.c **** 
 1815               		.loc 1 229 1 view .LVU489
 1816 0026 1F91      		pop r17
 1817 0028 0F91      		pop r16
 1818               	.LVL181:
 228:tmk_core/common/action.c **** }
 1819               		.loc 1 228 5 view .LVU490
 1820 002a 0C94 0000 		jmp process_action
 1821               	.LVL182:
 228:tmk_core/common/action.c **** }
 1822               		.loc 1 228 5 view .LVU491
 1823               		.cfi_endproc
 1824               	.LFE114:
 1826               		.section	.text.process_record,"ax",@progbits
 1827               	.global	process_record
 1829               	process_record:
 1830               	.LVL183:
 1831               	.LFB113:
 198:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1832               		.loc 1 198 42 is_stmt 1 view -0
 1833               		.cfi_startproc
 198:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1834               		.loc 1 198 42 is_stmt 0 view .LVU493
 1835 0000 CF93      		push r28
 1836               	.LCFI19:
 1837               		.cfi_def_cfa_offset 3
 1838               		.cfi_offset 28, -2
 1839 0002 DF93      		push r29
 1840               	.LCFI20:
 1841               		.cfi_def_cfa_offset 4
 1842               		.cfi_offset 29, -3
 1843               	/* prologue: function */
 1844               	/* frame size = 0 */
 1845               	/* stack size = 2 */
 1846               	.L__stack_usage = 2
 1847 0004 EC01      		movw r28,r24
 199:tmk_core/common/action.c ****         return;
 1848               		.loc 1 199 5 is_stmt 1 view .LVU494
 1849               	.LBB59:
 1850               	.LBI59:
 1851               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #pragma once
  19:tmk_core/common/keyboard.h **** 
  20:tmk_core/common/keyboard.h **** #include <stdbool.h>
  21:tmk_core/common/keyboard.h **** #include <stdint.h>
  22:tmk_core/common/keyboard.h **** 
  23:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  24:tmk_core/common/keyboard.h **** extern "C" {
  25:tmk_core/common/keyboard.h **** #endif
  26:tmk_core/common/keyboard.h **** 
  27:tmk_core/common/keyboard.h **** /* key matrix position */
  28:tmk_core/common/keyboard.h **** typedef struct {
  29:tmk_core/common/keyboard.h ****     uint8_t col;
  30:tmk_core/common/keyboard.h ****     uint8_t row;
  31:tmk_core/common/keyboard.h **** } keypos_t;
  32:tmk_core/common/keyboard.h **** 
  33:tmk_core/common/keyboard.h **** /* key event */
  34:tmk_core/common/keyboard.h **** typedef struct {
  35:tmk_core/common/keyboard.h ****     keypos_t key;
  36:tmk_core/common/keyboard.h ****     bool     pressed;
  37:tmk_core/common/keyboard.h ****     uint16_t time;
  38:tmk_core/common/keyboard.h **** } keyevent_t;
  39:tmk_core/common/keyboard.h **** 
  40:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  41:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  42:tmk_core/common/keyboard.h **** 
  43:tmk_core/common/keyboard.h **** /* Rules for No Event:
  44:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  45:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  46:tmk_core/common/keyboard.h ****  */
  47:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1852               		.loc 4 47 20 view .LVU495
 1853               	.LBB60:
 1854               		.loc 4 47 51 view .LVU496
 1855               		.loc 4 47 74 is_stmt 0 view .LVU497
 1856 0006 8B81      		ldd r24,Y+3
 1857 0008 9C81      		ldd r25,Y+4
 1858               	.LVL184:
 1859               		.loc 4 47 74 view .LVU498
 1860 000a 892B      		or r24,r25
 1861 000c 01F0      		breq .L165
 1862 000e 8881      		ld r24,Y
 1863 0010 9981      		ldd r25,Y+1
 1864 0012 8923      		and r24,r25
 1865 0014 8F3F      		cpi r24,lo8(-1)
 1866 0016 01F4      		brne .L181
 1867               	.L165:
 1868               	/* epilogue start */
 1869               	.LBE60:
 1870               	.LBE59:
 214:tmk_core/common/action.c **** 
 1871               		.loc 1 214 1 view .LVU499
 1872 0018 DF91      		pop r29
 1873 001a CF91      		pop r28
 1874               	.LVL185:
 214:tmk_core/common/action.c **** 
 1875               		.loc 1 214 1 view .LVU500
 1876 001c 0895      		ret
 1877               	.LVL186:
 1878               	.L170:
 212:tmk_core/common/action.c ****     post_process_record_quantum(record);
 1879               		.loc 1 212 5 is_stmt 1 view .LVU501
 1880 001e CE01      		movw r24,r28
 1881 0020 0E94 0000 		call process_record_handler
 1882               	.LVL187:
 213:tmk_core/common/action.c **** }
 1883               		.loc 1 213 5 view .LVU502
 1884 0024 CE01      		movw r24,r28
 1885               	/* epilogue start */
 214:tmk_core/common/action.c **** 
 1886               		.loc 1 214 1 is_stmt 0 view .LVU503
 1887 0026 DF91      		pop r29
 1888 0028 CF91      		pop r28
 1889               	.LVL188:
 213:tmk_core/common/action.c **** }
 1890               		.loc 1 213 5 view .LVU504
 1891 002a 0C94 0000 		jmp post_process_record_quantum
 1892               	.LVL189:
 1893               	.L181:
 203:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1894               		.loc 1 203 5 is_stmt 1 view .LVU505
 203:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1895               		.loc 1 203 10 is_stmt 0 view .LVU506
 1896 002e CE01      		movw r24,r28
 1897 0030 0E94 0000 		call process_record_quantum
 1898               	.LVL190:
 203:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1899               		.loc 1 203 8 view .LVU507
 1900 0034 8111      		cpse r24,__zero_reg__
 1901 0036 00C0      		rjmp .L170
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1902               		.loc 1 205 9 is_stmt 1 view .LVU508
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1903               		.loc 1 205 13 is_stmt 0 view .LVU509
 1904 0038 0E94 0000 		call is_oneshot_layer_active
 1905               	.LVL191:
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1906               		.loc 1 205 12 view .LVU510
 1907 003c 8823      		tst r24
 1908 003e 01F0      		breq .L165
 205:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1909               		.loc 1 205 39 discriminator 1 view .LVU511
 1910 0040 8A81      		ldd r24,Y+2
 1911 0042 8823      		tst r24
 1912 0044 01F0      		breq .L165
 206:tmk_core/common/action.c ****         }
 1913               		.loc 1 206 13 is_stmt 1 view .LVU512
 1914 0046 82E0      		ldi r24,lo8(2)
 1915               	/* epilogue start */
 214:tmk_core/common/action.c **** 
 1916               		.loc 1 214 1 is_stmt 0 view .LVU513
 1917 0048 DF91      		pop r29
 1918 004a CF91      		pop r28
 1919               	.LVL192:
 206:tmk_core/common/action.c ****         }
 1920               		.loc 1 206 13 view .LVU514
 1921 004c 0C94 0000 		jmp clear_oneshot_layer_state
 1922               	.LVL193:
 1923               		.cfi_endproc
 1924               	.LFE113:
 1926               		.section	.text.process_record_nocache,"ax",@progbits
 1927               	.global	process_record_nocache
 1929               	process_record_nocache:
 1930               	.LVL194:
 1931               	.LFB109:
 156:tmk_core/common/action.c ****     disable_action_cache = true;
 1932               		.loc 1 156 50 is_stmt 1 view -0
 1933               		.cfi_startproc
 1934               	/* prologue: function */
 1935               	/* frame size = 0 */
 1936               	/* stack size = 0 */
 1937               	.L__stack_usage = 0
 157:tmk_core/common/action.c ****     process_record(record);
 1938               		.loc 1 157 5 view .LVU516
 157:tmk_core/common/action.c ****     process_record(record);
 1939               		.loc 1 157 26 is_stmt 0 view .LVU517
 1940 0000 21E0      		ldi r18,lo8(1)
 1941 0002 2093 0000 		sts disable_action_cache,r18
 158:tmk_core/common/action.c ****     disable_action_cache = false;
 1942               		.loc 1 158 5 is_stmt 1 view .LVU518
 1943 0006 0E94 0000 		call process_record
 1944               	.LVL195:
 159:tmk_core/common/action.c **** }
 1945               		.loc 1 159 5 view .LVU519
 159:tmk_core/common/action.c **** }
 1946               		.loc 1 159 26 is_stmt 0 view .LVU520
 1947 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1948               	/* epilogue start */
 160:tmk_core/common/action.c **** #else
 1949               		.loc 1 160 1 view .LVU521
 1950 000e 0895      		ret
 1951               		.cfi_endproc
 1952               	.LFE109:
 1954               		.section	.text.register_weak_mods,"ax",@progbits
 1955               	.global	register_weak_mods
 1957               	register_weak_mods:
 1958               	.LVL196:
 1959               	.LFB121:
 974:tmk_core/common/action.c **** 
 975:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 976:tmk_core/common/action.c ****  *
 977:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 978:tmk_core/common/action.c ****  */
 979:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1960               		.loc 1 979 39 is_stmt 1 view -0
 1961               		.cfi_startproc
 1962               	/* prologue: function */
 1963               	/* frame size = 0 */
 1964               	/* stack size = 0 */
 1965               	.L__stack_usage = 0
 980:tmk_core/common/action.c ****     if (mods) {
 1966               		.loc 1 980 5 view .LVU523
 1967               		.loc 1 980 8 is_stmt 0 view .LVU524
 1968 0000 8823      		tst r24
 1969 0002 01F0      		breq .L184
 981:tmk_core/common/action.c ****         add_weak_mods(mods);
 1970               		.loc 1 981 9 is_stmt 1 view .LVU525
 1971 0004 0E94 0000 		call add_weak_mods
 1972               	.LVL197:
 982:tmk_core/common/action.c ****         send_keyboard_report();
 1973               		.loc 1 982 9 view .LVU526
 1974 0008 0C94 0000 		jmp send_keyboard_report
 1975               	.LVL198:
 1976               	.L184:
 1977               	/* epilogue start */
 983:tmk_core/common/action.c ****     }
 984:tmk_core/common/action.c **** }
 1978               		.loc 1 984 1 is_stmt 0 view .LVU527
 1979 000c 0895      		ret
 1980               		.cfi_endproc
 1981               	.LFE121:
 1983               		.section	.text.unregister_weak_mods,"ax",@progbits
 1984               	.global	unregister_weak_mods
 1986               	unregister_weak_mods:
 1987               	.LVL199:
 1988               	.LFB122:
 985:tmk_core/common/action.c **** 
 986:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 987:tmk_core/common/action.c ****  *
 988:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 989:tmk_core/common/action.c ****  */
 990:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1989               		.loc 1 990 41 is_stmt 1 view -0
 1990               		.cfi_startproc
 1991               	/* prologue: function */
 1992               	/* frame size = 0 */
 1993               	/* stack size = 0 */
 1994               	.L__stack_usage = 0
 991:tmk_core/common/action.c ****     if (mods) {
 1995               		.loc 1 991 5 view .LVU529
 1996               		.loc 1 991 8 is_stmt 0 view .LVU530
 1997 0000 8823      		tst r24
 1998 0002 01F0      		breq .L186
 992:tmk_core/common/action.c ****         del_weak_mods(mods);
 1999               		.loc 1 992 9 is_stmt 1 view .LVU531
 2000 0004 0E94 0000 		call del_weak_mods
 2001               	.LVL200:
 993:tmk_core/common/action.c ****         send_keyboard_report();
 2002               		.loc 1 993 9 view .LVU532
 2003 0008 0C94 0000 		jmp send_keyboard_report
 2004               	.LVL201:
 2005               	.L186:
 2006               	/* epilogue start */
 994:tmk_core/common/action.c ****     }
 995:tmk_core/common/action.c **** }
 2007               		.loc 1 995 1 is_stmt 0 view .LVU533
 2008 000c 0895      		ret
 2009               		.cfi_endproc
 2010               	.LFE122:
 2012               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2013               	.global	clear_keyboard_but_mods_and_keys
 2015               	clear_keyboard_but_mods_and_keys:
 2016               	.LFB125:
 996:tmk_core/common/action.c **** 
 997:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 998:tmk_core/common/action.c ****  *
 999:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1000:tmk_core/common/action.c ****  */
1001:tmk_core/common/action.c **** void clear_keyboard(void) {
1002:tmk_core/common/action.c ****     clear_mods();
1003:tmk_core/common/action.c ****     clear_keyboard_but_mods();
1004:tmk_core/common/action.c **** }
1005:tmk_core/common/action.c **** 
1006:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1007:tmk_core/common/action.c ****  *
1008:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1009:tmk_core/common/action.c ****  */
1010:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
1011:tmk_core/common/action.c ****     clear_keys();
1012:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
1013:tmk_core/common/action.c **** }
1014:tmk_core/common/action.c **** 
1015:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1016:tmk_core/common/action.c ****  *
1017:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1018:tmk_core/common/action.c ****  */
1019:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 2017               		.loc 1 1019 41 is_stmt 1 view -0
 2018               		.cfi_startproc
 2019               	/* prologue: function */
 2020               	/* frame size = 0 */
 2021               	/* stack size = 0 */
 2022               	.L__stack_usage = 0
1020:tmk_core/common/action.c ****     clear_weak_mods();
 2023               		.loc 1 1020 5 view .LVU535
 2024 0000 0E94 0000 		call clear_weak_mods
 2025               	.LVL202:
1021:tmk_core/common/action.c ****     clear_macro_mods();
 2026               		.loc 1 1021 5 view .LVU536
 2027 0004 0E94 0000 		call clear_macro_mods
 2028               	.LVL203:
1022:tmk_core/common/action.c ****     send_keyboard_report();
 2029               		.loc 1 1022 5 view .LVU537
 2030 0008 0E94 0000 		call send_keyboard_report
 2031               	.LVL204:
1023:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
1024:tmk_core/common/action.c ****     mousekey_clear();
1025:tmk_core/common/action.c ****     mousekey_send();
1026:tmk_core/common/action.c **** #endif
1027:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
1028:tmk_core/common/action.c ****     host_system_send(0);
 2032               		.loc 1 1028 5 view .LVU538
 2033 000c 90E0      		ldi r25,0
 2034 000e 80E0      		ldi r24,0
 2035 0010 0E94 0000 		call host_system_send
 2036               	.LVL205:
1029:tmk_core/common/action.c ****     host_consumer_send(0);
 2037               		.loc 1 1029 5 view .LVU539
 2038 0014 90E0      		ldi r25,0
 2039 0016 80E0      		ldi r24,0
 2040 0018 0C94 0000 		jmp host_consumer_send
 2041               	.LVL206:
 2042               		.cfi_endproc
 2043               	.LFE125:
 2045               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2046               	.global	clear_keyboard_but_mods
 2048               	clear_keyboard_but_mods:
 2049               	.LFB124:
1010:tmk_core/common/action.c ****     clear_keys();
 2050               		.loc 1 1010 36 view -0
 2051               		.cfi_startproc
 2052               	/* prologue: function */
 2053               	/* frame size = 0 */
 2054               	/* stack size = 0 */
 2055               	.L__stack_usage = 0
1011:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 2056               		.loc 1 1011 5 view .LVU541
 2057 0000 0E94 0000 		call clear_keys
 2058               	.LVL207:
1012:tmk_core/common/action.c **** }
 2059               		.loc 1 1012 5 view .LVU542
 2060 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2061               	.LVL208:
 2062               		.cfi_endproc
 2063               	.LFE124:
 2065               		.section	.text.clear_keyboard,"ax",@progbits
 2066               	.global	clear_keyboard
 2068               	clear_keyboard:
 2069               	.LFB123:
1001:tmk_core/common/action.c ****     clear_mods();
 2070               		.loc 1 1001 27 view -0
 2071               		.cfi_startproc
 2072               	/* prologue: function */
 2073               	/* frame size = 0 */
 2074               	/* stack size = 0 */
 2075               	.L__stack_usage = 0
1002:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2076               		.loc 1 1002 5 view .LVU544
 2077 0000 0E94 0000 		call clear_mods
 2078               	.LVL209:
1003:tmk_core/common/action.c **** }
 2079               		.loc 1 1003 5 view .LVU545
 2080 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2081               	.LVL210:
 2082               		.cfi_endproc
 2083               	.LFE123:
 2085               		.section	.text.is_tap_action,"ax",@progbits
 2086               	.global	is_tap_action
 2088               	is_tap_action:
 2089               	.LVL211:
 2090               	.LFB127:
1030:tmk_core/common/action.c **** #endif
1031:tmk_core/common/action.c **** }
1032:tmk_core/common/action.c **** 
1033:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1034:tmk_core/common/action.c ****  *
1035:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1036:tmk_core/common/action.c ****  */
1037:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
1038:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
1039:tmk_core/common/action.c ****     return is_tap_action(action);
1040:tmk_core/common/action.c **** }
1041:tmk_core/common/action.c **** 
1042:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1043:tmk_core/common/action.c ****  *
1044:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1045:tmk_core/common/action.c ****  */
1046:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 2091               		.loc 1 1046 37 view -0
 2092               		.cfi_startproc
 2093               	/* prologue: function */
 2094               	/* frame size = 0 */
 2095               	/* stack size = 0 */
 2096               	.L__stack_usage = 0
1047:tmk_core/common/action.c ****     switch (action.kind.id) {
 2097               		.loc 1 1047 5 view .LVU547
 2098               		.loc 1 1047 24 is_stmt 0 view .LVU548
 2099 0000 E92F      		mov r30,r25
 2100 0002 E295      		swap r30
 2101 0004 EF70      		andi r30,lo8(15)
 2102               		.loc 1 1047 5 view .LVU549
 2103 0006 E250      		subi r30,lo8(-(-2))
 2104 0008 EE30      		cpi r30,lo8(14)
 2105 000a 00F4      		brsh .L200
 2106 000c F0E0      		ldi r31,0
 2107 000e E050      		subi r30,lo8(-(gs(.L194)))
 2108 0010 F040      		sbci r31,hi8(-(gs(.L194)))
 2109 0012 0C94 0000 		jmp __tablejump2__
 2110               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2111               		.p2align	1
 2112               	.L194:
 2113 0000 0000      		.word gs(.L195)
 2114 0002 0000      		.word gs(.L195)
 2115 0004 0000      		.word gs(.L200)
 2116 0006 0000      		.word gs(.L200)
 2117 0008 0000      		.word gs(.L196)
 2118 000a 0000      		.word gs(.L200)
 2119 000c 0000      		.word gs(.L200)
 2120 000e 0000      		.word gs(.L200)
 2121 0010 0000      		.word gs(.L195)
 2122 0012 0000      		.word gs(.L195)
 2123 0014 0000      		.word gs(.L193)
 2124 0016 0000      		.word gs(.L200)
 2125 0018 0000      		.word gs(.L200)
 2126 001a 0000      		.word gs(.L193)
 2127               		.section	.text.is_tap_action
 2128               	.L195:
1048:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1049:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1050:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1051:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1052:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2129               		.loc 1 1052 13 is_stmt 1 view .LVU550
 2130 0016 803F      		cpi r24,lo8(-16)
 2131 0018 01F0      		breq .L203
 2132 001a 00F4      		brsh .L197
 2133 001c 883E      		cpi r24,lo8(-24)
 2134 001e 00F4      		brsh .L200
 2135               	.L203:
1053:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1054:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1055:tmk_core/common/action.c ****                 case OP_ONESHOT:
1056:tmk_core/common/action.c ****                     return true;
 2136               		.loc 1 1056 28 is_stmt 0 view .LVU551
 2137 0020 81E0      		ldi r24,lo8(1)
 2138               	.LVL212:
 2139               	/* epilogue start */
1057:tmk_core/common/action.c ****             }
1058:tmk_core/common/action.c ****             return false;
1059:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1060:tmk_core/common/action.c ****             switch (action.swap.code) {
1061:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1062:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1063:tmk_core/common/action.c ****                     return true;
1064:tmk_core/common/action.c ****             }
1065:tmk_core/common/action.c ****             return false;
1066:tmk_core/common/action.c ****         case ACT_MACRO:
1067:tmk_core/common/action.c ****         case ACT_FUNCTION:
1068:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1069:tmk_core/common/action.c ****                 return true;
1070:tmk_core/common/action.c ****             }
1071:tmk_core/common/action.c ****             return false;
1072:tmk_core/common/action.c ****     }
1073:tmk_core/common/action.c ****     return false;
1074:tmk_core/common/action.c **** }
 2140               		.loc 1 1074 1 view .LVU552
 2141 0022 0895      		ret
 2142               	.LVL213:
 2143               	.L197:
 2144               		.loc 1 1074 1 view .LVU553
 2145 0024 843F      		cpi r24,lo8(-12)
 2146 0026 01F0      		breq .L203
 2147               	.L200:
1058:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2148               		.loc 1 1058 20 view .LVU554
 2149 0028 80E0      		ldi r24,0
 2150               	.LVL214:
1058:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2151               		.loc 1 1058 20 view .LVU555
 2152 002a 0895      		ret
 2153               	.LVL215:
 2154               	.L196:
1060:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 2155               		.loc 1 1060 13 is_stmt 1 view .LVU556
 2156 002c 883E      		cpi r24,lo8(-24)
 2157 002e 00F0      		brlo .L203
 2158 0030 813F      		cpi r24,lo8(-15)
 2159 0032 01F4      		brne .L200
 2160 0034 00C0      		rjmp .L203
 2161               	.L193:
1068:tmk_core/common/action.c ****                 return true;
 2162               		.loc 1 1068 13 view .LVU557
1068:tmk_core/common/action.c ****                 return true;
 2163               		.loc 1 1068 16 is_stmt 0 view .LVU558
 2164 0036 93FB      		bst r25,3
 2165 0038 8827      		clr r24
 2166 003a 80F9      		bld r24,0
 2167               	.LVL216:
1068:tmk_core/common/action.c ****                 return true;
 2168               		.loc 1 1068 16 view .LVU559
 2169 003c 0895      		ret
 2170               		.cfi_endproc
 2171               	.LFE127:
 2173               		.section	.text.is_tap_key,"ax",@progbits
 2174               	.global	is_tap_key
 2176               	is_tap_key:
 2177               	.LVL217:
 2178               	.LFB126:
1037:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2179               		.loc 1 1037 31 is_stmt 1 view -0
 2180               		.cfi_startproc
 2181               	/* prologue: function */
 2182               	/* frame size = 0 */
 2183               	/* stack size = 0 */
 2184               	.L__stack_usage = 0
1038:tmk_core/common/action.c ****     return is_tap_action(action);
 2185               		.loc 1 1038 5 view .LVU561
1038:tmk_core/common/action.c ****     return is_tap_action(action);
 2186               		.loc 1 1038 23 is_stmt 0 view .LVU562
 2187 0000 0E94 0000 		call layer_switch_get_action
 2188               	.LVL218:
1039:tmk_core/common/action.c **** }
 2189               		.loc 1 1039 5 is_stmt 1 view .LVU563
1039:tmk_core/common/action.c **** }
 2190               		.loc 1 1039 12 is_stmt 0 view .LVU564
 2191 0004 0C94 0000 		jmp is_tap_action
 2192               	.LVL219:
 2193               		.cfi_endproc
 2194               	.LFE126:
 2196               		.section	.text.debug_event,"ax",@progbits
 2197               	.global	debug_event
 2199               	debug_event:
 2200               	.LFB128:
1075:tmk_core/common/action.c **** 
1076:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1077:tmk_core/common/action.c ****  *
1078:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1079:tmk_core/common/action.c ****  */
1080:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2201               		.loc 1 1080 36 is_stmt 1 view -0
 2202               		.cfi_startproc
 2203 0000 CF93      		push r28
 2204               	.LCFI21:
 2205               		.cfi_def_cfa_offset 3
 2206               		.cfi_offset 28, -2
 2207 0002 DF93      		push r29
 2208               	.LCFI22:
 2209               		.cfi_def_cfa_offset 4
 2210               		.cfi_offset 29, -3
 2211 0004 00D0      		rcall .
 2212 0006 00D0      		rcall .
 2213 0008 0F92      		push __tmp_reg__
 2214               	.LCFI23:
 2215               		.cfi_def_cfa_offset 9
 2216 000a CDB7      		in r28,__SP_L__
 2217 000c DEB7      		in r29,__SP_H__
 2218               	.LCFI24:
 2219               		.cfi_def_cfa_register 28
 2220               	/* prologue: function */
 2221               	/* frame size = 5 */
 2222               	/* stack size = 7 */
 2223               	.L__stack_usage = 7
 2224               		.loc 1 1080 138 view .LVU566
 2225               	/* epilogue start */
 2226               		.loc 1 1080 1 is_stmt 0 view .LVU567
 2227 000e 0F90      		pop __tmp_reg__
 2228 0010 0F90      		pop __tmp_reg__
 2229 0012 0F90      		pop __tmp_reg__
 2230 0014 0F90      		pop __tmp_reg__
 2231 0016 0F90      		pop __tmp_reg__
 2232 0018 DF91      		pop r29
 2233 001a CF91      		pop r28
 2234 001c 0895      		ret
 2235               		.cfi_endproc
 2236               	.LFE128:
 2238               		.section	.text.debug_record,"ax",@progbits
 2239               	.global	debug_record
 2241               	debug_record:
 2242               	.LFB129:
1081:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1082:tmk_core/common/action.c ****  *
1083:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1084:tmk_core/common/action.c ****  */
1085:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2243               		.loc 1 1085 39 is_stmt 1 view -0
 2244               		.cfi_startproc
 2245 0000 CF93      		push r28
 2246               	.LCFI25:
 2247               		.cfi_def_cfa_offset 3
 2248               		.cfi_offset 28, -2
 2249 0002 DF93      		push r29
 2250               	.LCFI26:
 2251               		.cfi_def_cfa_offset 4
 2252               		.cfi_offset 29, -3
 2253 0004 00D0      		rcall .
 2254 0006 00D0      		rcall .
 2255 0008 00D0      		rcall .
 2256               	.LCFI27:
 2257               		.cfi_def_cfa_offset 10
 2258 000a CDB7      		in r28,__SP_L__
 2259 000c DEB7      		in r29,__SP_H__
 2260               	.LCFI28:
 2261               		.cfi_def_cfa_register 28
 2262               	/* prologue: function */
 2263               	/* frame size = 6 */
 2264               	/* stack size = 8 */
 2265               	.L__stack_usage = 8
1086:tmk_core/common/action.c ****     debug_event(record.event);
 2266               		.loc 1 1086 5 view .LVU569
1087:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1088:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2267               		.loc 1 1088 77 view .LVU570
 2268               	/* epilogue start */
1089:tmk_core/common/action.c **** #endif
1090:tmk_core/common/action.c **** }
 2269               		.loc 1 1090 1 is_stmt 0 view .LVU571
 2270 000e 2696      		adiw r28,6
 2271 0010 0FB6      		in __tmp_reg__,__SREG__
 2272 0012 F894      		cli
 2273 0014 DEBF      		out __SP_H__,r29
 2274 0016 0FBE      		out __SREG__,__tmp_reg__
 2275 0018 CDBF      		out __SP_L__,r28
 2276 001a DF91      		pop r29
 2277 001c CF91      		pop r28
 2278 001e 0895      		ret
 2279               		.cfi_endproc
 2280               	.LFE129:
 2282               		.section	.text.debug_action,"ax",@progbits
 2283               	.global	debug_action
 2285               	debug_action:
 2286               	.LVL220:
 2287               	.LFB130:
1091:tmk_core/common/action.c **** 
1092:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1093:tmk_core/common/action.c ****  *
1094:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1095:tmk_core/common/action.c ****  */
1096:tmk_core/common/action.c **** void debug_action(action_t action) {
 2288               		.loc 1 1096 36 is_stmt 1 view -0
 2289               		.cfi_startproc
 2290               	/* prologue: function */
 2291               	/* frame size = 0 */
 2292               	/* stack size = 0 */
 2293               	.L__stack_usage = 0
1097:tmk_core/common/action.c ****     switch (action.kind.id) {
 2294               		.loc 1 1097 5 view .LVU573
1098:tmk_core/common/action.c ****         case ACT_LMODS:
1099:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1100:tmk_core/common/action.c ****             break;
1101:tmk_core/common/action.c ****         case ACT_RMODS:
1102:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1103:tmk_core/common/action.c ****             break;
1104:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1105:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1106:tmk_core/common/action.c ****             break;
1107:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1108:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1109:tmk_core/common/action.c ****             break;
1110:tmk_core/common/action.c ****         case ACT_USAGE:
1111:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1112:tmk_core/common/action.c ****             break;
1113:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1114:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1115:tmk_core/common/action.c ****             break;
1116:tmk_core/common/action.c ****         case ACT_LAYER:
1117:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1118:tmk_core/common/action.c ****             break;
1119:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1120:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1121:tmk_core/common/action.c ****             break;
1122:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1123:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1124:tmk_core/common/action.c ****             break;
1125:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1126:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1127:tmk_core/common/action.c ****             break;
1128:tmk_core/common/action.c ****         case ACT_MACRO:
1129:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1130:tmk_core/common/action.c ****             break;
1131:tmk_core/common/action.c ****         case ACT_FUNCTION:
1132:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1133:tmk_core/common/action.c ****             break;
1134:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1135:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1136:tmk_core/common/action.c ****             break;
1137:tmk_core/common/action.c ****         default:
1138:tmk_core/common/action.c ****             dprint("UNKNOWN");
1139:tmk_core/common/action.c ****             break;
1140:tmk_core/common/action.c ****     }
1141:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2295               		.loc 1 1141 75 view .LVU574
 2296               	/* epilogue start */
1142:tmk_core/common/action.c **** }
 2297               		.loc 1 1142 1 is_stmt 0 view .LVU575
 2298 0000 0895      		ret
 2299               		.cfi_endproc
 2300               	.LFE130:
 2302               		.section	.rodata.CSWTCH.11,"a"
 2305               	CSWTCH.11:
 2306 0000 E200      		.word	226
 2307 0002 E900      		.word	233
 2308 0004 EA00      		.word	234
 2309 0006 B500      		.word	181
 2310 0008 B600      		.word	182
 2311 000a B700      		.word	183
 2312 000c CD00      		.word	205
 2313 000e 8301      		.word	387
 2314 0010 CC00      		.word	204
 2315 0012 8A01      		.word	394
 2316 0014 9201      		.word	402
 2317 0016 9401      		.word	404
 2318 0018 2102      		.word	545
 2319 001a 2302      		.word	547
 2320 001c 2402      		.word	548
 2321 001e 2502      		.word	549
 2322 0020 2602      		.word	550
 2323 0022 2702      		.word	551
 2324 0024 2A02      		.word	554
 2325 0026 B300      		.word	179
 2326 0028 B400      		.word	180
 2327 002a 6F00      		.word	111
 2328 002c 7000      		.word	112
 2329               		.section	.rodata.CSWTCH.10,"a"
 2332               	CSWTCH.10:
 2333 0000 81        		.byte	-127
 2334 0001 82        		.byte	-126
 2335 0002 83        		.byte	-125
 2336               	.global	disable_action_cache
 2337               		.section	.bss.disable_action_cache,"aw",@nobits
 2340               	disable_action_cache:
 2341 0000 00        		.zero	1
 2342               		.comm	tp_buttons,2,1
 2343               		.text
 2344               	.Letext0:
 2345               		.file 5 "c:\\program files\\qmk_msys\\mingw64\\avr\\include\\stdint.h"
 2346               		.file 6 "tmk_core/common/keycode.h"
 2347               		.file 7 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 2348               		.file 8 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 2349               		.file 9 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2350               		.file 10 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 2351               		.file 11 "c:\\program files\\qmk_msys\\mingw64\\avr\\include\\stdio.h"
 2352               		.file 12 "tmk_core/common/host.h"
 2353               		.file 13 "tmk_core/common/mousekey.h"
 2354               		.file 14 "tmk_core/common/command.h"
 2355               		.file 15 "tmk_core/common/action_code.h"
 2356               		.file 16 "tmk_core/common/action.h"
 2357               		.file 17 "tmk_core/common/action_layer.h"
 2358               		.file 18 "tmk_core/common/action_util.h"
 2359               		.file 19 "tmk_core/common/debug.h"
 2360               		.file 20 "tmk_core/common/led.h"
 2361               		.file 21 "tmk_core/common/action_macro.h"
 2362               		.file 22 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2      *ABS*:000000000000003e __SP_H__
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:3      *ABS*:000000000000003d __SP_L__
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:4      *ABS*:000000000000003f __SREG__
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:5      *ABS*:0000000000000000 __tmp_reg__
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:6      *ABS*:0000000000000001 __zero_reg__
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:13     .text.action_exec:0000000000000000 action_exec
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:94     .text.process_record_quantum:0000000000000000 process_record_quantum
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:116    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:135    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:160    .text.register_code:0000000000000000 register_code
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2332   .rodata.CSWTCH.10:0000000000000000 CSWTCH.10
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2305   .rodata.CSWTCH.11:0000000000000000 CSWTCH.11
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:459    .text.unregister_code:0000000000000000 unregister_code
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:617    .text.tap_code:0000000000000000 tap_code
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:681    .text.register_mods:0000000000000000 register_mods
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:710    .text.unregister_mods:0000000000000000 unregister_mods
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:739    .text.process_action:0000000000000000 process_action
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:1829   .text.process_record:0000000000000000 process_record
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:1757   .text.process_record_handler:0000000000000000 process_record_handler
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:1929   .text.process_record_nocache:0000000000000000 process_record_nocache
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2340   .bss.disable_action_cache:0000000000000000 disable_action_cache
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:1957   .text.register_weak_mods:0000000000000000 register_weak_mods
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:1986   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2015   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2048   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2068   .text.clear_keyboard:0000000000000000 clear_keyboard
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2088   .text.is_tap_action:0000000000000000 is_tap_action
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2176   .text.is_tap_key:0000000000000000 is_tap_key
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2199   .text.debug_event:0000000000000000 debug_event
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2241   .text.debug_record:0000000000000000 debug_record
C:\Users\gazed\AppData\Local\Temp\ccJTIDMT.s:2285   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
keyboard_report
is_key_pressed
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
